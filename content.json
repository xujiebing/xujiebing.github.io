{"meta":{"title":"大兵的博客","subtitle":null,"description":null,"author":"大兵","url":"https://xujiebing.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-06-22T14:45:27.975Z","updated":"2019-06-22T07:57:39.322Z","comments":false,"path":"about/index.html","permalink":"https://xujiebing.github.io/about/index.html","excerpt":"","text":"个人详细介绍！！！"},{"title":"分类","date":"2019-06-21T06:25:24.268Z","updated":"2019-06-20T17:04:01.405Z","comments":false,"path":"categories/index.html","permalink":"https://xujiebing.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-21T06:27:31.333Z","updated":"2019-06-20T16:01:12.954Z","comments":false,"path":"tags/index.html","permalink":"https://xujiebing.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-06-22T15:42:29.092Z","updated":"2019-06-20T16:01:12.954Z","comments":false,"path":"repository/index.html","permalink":"https://xujiebing.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-06-27T09:40:21.669Z","updated":"2019-06-22T08:07:58.232Z","comments":true,"path":"links/index.html","permalink":"https://xujiebing.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-06-27T09:41:40.559Z","updated":"2019-06-27T09:41:40.552Z","comments":false,"path":"books/index.html","permalink":"https://xujiebing.github.io/books/index.html","excerpt":"","text":"汇编语言入门教程-阮一峰 ECMAScript 6 入门-阮一峰"}],"posts":[{"title":"ReactNative开发踩坑记录","slug":"ReactNative开发踩坑记录","date":"2019-07-03T02:48:58.000Z","updated":"2019-07-03T02:58:55.617Z","comments":true,"path":"2019/07/03/ReactNative开发踩坑记录/","link":"","permalink":"https://xujiebing.github.io/2019/07/03/ReactNative开发踩坑记录/","excerpt":"","text":"Could not find iPhone XXX描述： 终端运行react-native run-ios时报错，无法找到模拟器，通过xcrun simctl list devices命令查看本地模拟器列表，已经包含了运行的模拟器 原因： 不能再通过cli运行react-native run-ios 解决方案： 进入/node_modules/react-native/local-cli/runIOS/findMatchingSimulator.js,将if (!version.startsWith(&#39;iOS&#39;) &amp;&amp; !version.startsWith(&#39;tvOS&#39;))修改为if (!version.startsWith(&#39;com.apple.CoreSimulator.SimRuntime.iOS&#39;) &amp;&amp; !version.startsWith(&#39;com.apple.CoreSimulator.SimRuntime.tvOS&#39;))","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://xujiebing.github.io/categories/ReactNative/"}],"tags":[{"name":"React","slug":"React","permalink":"https://xujiebing.github.io/tags/React/"}]},{"title":"App启动速度优化与监控(二)","slug":"App启动速度优化与监控(二)","date":"2019-06-26T12:00:46.000Z","updated":"2019-07-03T01:29:42.624Z","comments":true,"path":"2019/06/26/App启动速度优化与监控(二)/","link":"","permalink":"https://xujiebing.github.io/2019/06/26/App启动速度优化与监控(二)/","excerpt":"","text":"App启动App启动类型 冷启动 冷启动是指， App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。 热启动 热启动是指 ，App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。 App启动三个阶段 main() 函数执行前； 在 main() 函数执行前，系统主要会做下面几件事情： 加载可执行文件（App 的.o 文件的集合）； 加载动态链接库，进行 rebase 指针调整和 bind 符号绑定； Objc 运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等； 初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。 在该阶段可以做一些事情来优化App的启动速度： 减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持 6 个非系统动态库合并为一个。 减少加载启动后不会去使用的类或者方法。 +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个+load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。 控制 C++ 全局变量的数量。 main() 函数执行后； main() 函数执行后的阶段，指的是从 main() 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。 首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括： 首屏初始化所需配置文件的读写操作； 首屏列表大数据的读取； 首屏渲染的大量计算等。 首屏渲染完成后。 首屏渲染后的这个阶段，主要完成的是，非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等。从函数上来看，这个阶段指的就是截止到 didFinishLaunchingWithOptions 方法作用域内执行首屏渲染之后的所有方法执行完成。简单说的话，这个阶段就是从渲染完成时开始，到 didFinishLaunchingWithOptions 方法作用域结束时结束。 这个阶段用户已经能够看到 App 的首页信息了，所以优化的优先级排在最后。但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作。 查看App启动耗时查看main()调用前花费的总时间在Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Arguments-&gt;Environment Variables-&gt;DYLD_PRINT_STATISTICS设置为YES，就可以在控制台中查看main函数执行前总共花费的多长时间。 查看加载了多少动态库在Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Diagnostics-&gt;Logging-&gt;勾选Dynamic Library Loads，就可以在控制台中查看本项目中加载的所有动态库（包括系统的和自己的）。 查看Main函数启动后的耗时main函数调用后的耗时，可以使用一些工具来监控，有一种非常笨但是很实用的方法，就是通过打点，在didFinishLaunchingWithOptions开始前打一个点，在App显示完成第一个界面再打一个点，计算两个点之间的耗时，就可以知道main函数调用后到界面显示出来的耗时了，但是这样只能笼统的知道总的耗时，并不能准确的知道时间花在了哪里。 如果想用这个打点法的话，推荐一个打点工具BLStopwatch App启动速度优化功能级别的启动优化功能级别的启动优化要从main()函数执行后这个阶段下手。思路： main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。 方法级别的启动优化优化对资源的操作将主线程上线耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载、编辑、存储图片和文件等资源。 对App启动方法耗时进行监控 定时抓取主线程上的方法调用栈，计算一段时间里各个方法耗时 定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确 而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确 这个定时时间小于所有方法的执行时间(如：0.002秒)，那么基本就能监控到所有方法，但是这样计算出来的整体耗时不够准确。一般将这个时间间隔设置成0.01秒，这样虽然很多方法耗时不准确，但是整体耗时比较准确。所以这种方式虽然单个方法耗时不是非常准确，但是相对来说，整体耗时精度够用。如，Xcode自带TimeProfiler就是采用这种方式计算的。 对 objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时。 hook 方法的意思是，在原方法开始执行时换成执行其他你指定的方法，或者在原有方法执行前后执行你指定的方法，来达到掌握和改变指定方法的目的 hook objc_msgSend 这种方式的优点是非常精确，而缺点是只能针对 Objective-C 的方法。当然，对于 c 方法和 block 也不是没有办法，你可以使用 libffi 的 ffi_call 来达成 hook，但缺点就是编写维护相关工具门槛高 综上，如果对于检查结果精准度要求高的话，我比较推荐你使用 hook objc_msgSend 方式来检查启动方法的执行耗时。 如何做一个方法级别启动耗时检查工具来辅助分析和监控？由于能力有限，根据第一种方法做出来一个计算某个线程的耗时工具，放在了这里BSMonitorTimeTool，大致思路如下： 通过定时器，每隔0.01s，获取一次主线程的函数堆栈，将函数名称、函数地址、函数耗时模型化为TimeModel，保存在callStackDict中，其中key为函数地址，value为TimeModel 定时执行的回调中，每次都判断函数地址是否存在，如果已经存在此函数地址，就讲对应的TimeModel中的耗时增加0.01s；如果不存在此函数地址，就初始化一个TimeModel，并将时间设置为0.01s。 当主界面显示完成之后，输出此callStackDict，即可查看主线程中每个方法的耗时","categories":[{"name":"iOS","slug":"iOS","permalink":"https://xujiebing.github.io/categories/iOS/"}],"tags":[{"name":"iOS开发高手课","slug":"iOS开发高手课","permalink":"https://xujiebing.github.io/tags/iOS开发高手课/"}]},{"title":"Cocoapods常用操作命令","slug":"Cocoapods常用操作命令","date":"2019-06-25T15:37:46.000Z","updated":"2019-06-26T09:20:09.327Z","comments":true,"path":"2019/06/25/Cocoapods常用操作命令/","link":"","permalink":"https://xujiebing.github.io/2019/06/25/Cocoapods常用操作命令/","excerpt":"","text":"1.Pod安装 创建Podfile文件 1pod init 安装podfile中的远程库 1pod install 安装podfile中的远程库，但不更新本地spec文件 2.缓存相关 查看所有spec文件的缓存，可以直接到路径下删除文件 1pod cache list 删除制定的缓存文件 1pod cache clean AFNetworking","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xujiebing.github.io/categories/开发工具/"}],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://xujiebing.github.io/tags/CocoaPods/"}]},{"title":"SourceTree如何跳过注册直接使用","slug":"SourceTree如何跳过注册直接使用","date":"2019-06-25T04:34:11.000Z","updated":"2019-06-25T16:27:12.919Z","comments":true,"path":"2019/06/25/SourceTree如何跳过注册直接使用/","link":"","permalink":"https://xujiebing.github.io/2019/06/25/SourceTree如何跳过注册直接使用/","excerpt":"","text":"Mac上SourceTree免注册使用方式​ 为什么我会总结这篇文章，想必不用多少。SourceTree的注册问题一直是个头疼的问题，一次无意中发现这么个骚操作，预计记录下来。话不多少，开始正题。 1. 下载应用​ 自行下载SourceTree应用，也可以在该链接下载。SourceTree2.7.6 密码:gjg6 2. 安装应用​ 安装下载好的程序，知道这一步 ​ ​ 然后点击取消安装，关闭SourceTree 3. 删除文件​ 划重点，关键步骤。 ​ 右键应用程序中SourceTree，显示包内容，然后在Contents文件夹中搜索Atlassian，结果如图 ​ ​ 最后一个操作，删除搜索到的所有文件，整个流程结束。 ​ 可以愉快的使用SourceTree了。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xujiebing.github.io/categories/开发工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://xujiebing.github.io/tags/Mac/"}]},{"title":"Xcode打包异常集合","slug":"Xcode打包异常集合","date":"2019-06-24T14:10:47.000Z","updated":"2019-06-24T14:16:33.962Z","comments":true,"path":"2019/06/24/Xcode打包异常集合/","link":"","permalink":"https://xujiebing.github.io/2019/06/24/Xcode打包异常集合/","excerpt":"","text":"1. AppStore上传鉴定时报错Xcode上传AppStore验证时报错： Unable to download a software component: com.apple.transporter.mediatoolkit/1.13.0 这个错误是下载jar包失败，按照以下步骤执行，执行完之后，重新上传验证 123cd ~mv .itmstransporter/.old_itmstransporter/&quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporter&quot;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://xujiebing.github.io/categories/iOS/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://xujiebing.github.io/tags/Xcode/"}]},{"title":"iOS开发知识体系(一)","slug":"iOS开发知识体系(一)","date":"2019-06-23T15:46:18.000Z","updated":"2019-06-25T04:37:24.365Z","comments":true,"path":"2019/06/23/iOS开发知识体系(一)/","link":"","permalink":"https://xujiebing.github.io/2019/06/23/iOS开发知识体系(一)/","excerpt":"","text":"graph LR iOS(iOS知识体系)-->Base(基础) iOS-->App(应用开发) iOS-->Principle(原理) iOS-->NativeAndWeb(原生与前端) %%基础 Base-->Base_Code(开发阶段) Base-->Base_Test(调试测试阶段) Base-->Base_Release(发布阶段) Base-->Base_Online(上线阶段) Base_Code-->Base_Code0(启动流程) Base_Code-->Base_Code1(界面布局) Base_Code-->Base_Code2(架构设计) Base_Test-->Base_Test0(提速调试) Base_Test-->Base_Test1(静态分析) Base_Release-->Base_Release0(自动埋点) Base_Release-->Base_Release1(体积优化) Base_Online-->Base_Online0(崩溃分析) Base_Online-->Base_Online1(卡顿监控) Base_Online-->Base_Online2(日志搜集) Base_Online-->Base_Online3(性能监控) Base_Online-->Base_Online4(多线程问题) Base_Online-->Base_Online5(电量问题) %%应用开发 App-->App0(GUI框架) App0-->App0_0(UIKit) App0-->App0_1(Core Animation) App0-->App0_2(Core Graphics) App0-->App0_3(Core Image) App0-->App0_4(OpenGL ES) App-->App1(响应式框架) App1-->App1_0(ReactCocoa) App1-->App1_1(RxSwift) App1-->App1_2(EasyReact) App-->App2(动画) App2-->App2_0(Pop) App2-->App2_1(RZTransitions) App-->App3(A/B方案) App-->App4(消息总线) App4-->App4_0(PromiseKit) App4-->App4_1(SwiftTask) App-->App5(JSON处理) App5-->App5_0(JSONModel) App5-->App5_1(Mantle) App5-->App5_2(JSONDecoder) App-->App6(布局框架) App6-->App6_0(Masonry) App6-->App6_1(SnapKit) App6-->App6_2(Cartography) App6-->App6_3(Yoga) App-->App7(富文本) App7-->App7_0(YYText) App7-->App7_1(DTCoreText) App-->App8(TDD/BDD) App-->App9(编码规范) %%原理 Principle-->Principle0(系统内核 XNU) Principle-->Principle1(AOP) Principle1-->Principle1_0(Runtime Method Swizzling) Principle1-->Principle1_1(libffi) Principle-->Principle2(内存管理) Principle-->Principle3(编译) %%原生与前端 NativeAndWeb-->NativeAndWeb0(JavaScriptCore) NativeAndWeb-->NativeAndWeb1(跨端方案) NativeAndWeb1-->NativeAndWeb1_0(React Native) NativeAndWeb1-->NativeAndWeb1_1(Weex) NativeAndWeb1-->NativeAndWeb1_2(Flutter) NativeAndWeb1-->NativeAndWeb1_3(H5) NativeAndWeb-->NativeAndWeb2(布局区别) NativeAndWeb2-->NativeAndWeb2_0(原生布局) NativeAndWeb2-->NativeAndWeb2_1(前端布局) NativeAndWeb-->NativeAndWeb3(渲染区别) NativeAndWeb3-->NativeAndWeb3_0(原生渲染) NativeAndWeb3-->NativeAndWeb3_1(React Native渲染) NativeAndWeb3-->NativeAndWeb3_2(Flutter渲染) NativeAndWeb-->NativeAndWeb4(动态化方案分析) NativeAndWeb4-->NativeAndWeb4_0(WaxPatch) NativeAndWeb4-->NativeAndWeb4_1(JSPatch) NativeAndWeb4-->NativeAndWeb4_2(OCS) NativeAndWeb4-->NativeAndWeb4_3(低风险方案)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://xujiebing.github.io/categories/iOS/"}],"tags":[{"name":"iOS开发高手课","slug":"iOS开发高手课","permalink":"https://xujiebing.github.io/tags/iOS开发高手课/"}]},{"title":"iOS进入后台申请活跃时间","slug":"iOS进入后台申请活跃时间","date":"2019-06-22T15:19:55.000Z","updated":"2019-06-22T15:20:44.168Z","comments":true,"path":"2019/06/22/iOS进入后台申请活跃时间/","link":"","permalink":"https://xujiebing.github.io/2019/06/22/iOS进入后台申请活跃时间/","excerpt":"","text":"比较简单，废话不多说，直接上代码。 BackgroundTask","categories":[{"name":"iOS","slug":"iOS","permalink":"https://xujiebing.github.io/categories/iOS/"}],"tags":[]},{"title":"Cocoapods创建podspec说明","slug":"Cocoapods创建podspec说明","date":"2019-06-22T14:58:57.000Z","updated":"2019-06-25T15:37:11.037Z","comments":true,"path":"2019/06/22/Cocoapods创建podspec说明/","link":"","permalink":"https://xujiebing.github.io/2019/06/22/Cocoapods创建podspec说明/","excerpt":"","text":"一.创建远程私有库创建一个私有的podspec包括如下那么几个步骤: 123456- 创建并设置一个私有的Spec Repo。 - 创建Pod所需要的项目工程文件。- 向远程仓库提交工程项目。- 向私有的Spec Repo中提交podspec- 在个人项目中引入私有库。 - 更新维护podspec。 在整个过程中我们一共需要两个Git仓库。一个是用来放Pods索引的，也就是第一步中用到的，而且只有在第一次创建远程库时才需要；另一个是用来存放工程代码的远程仓库，不一定是Git仓库，其它的远程仓库也可以，本文以Git来介绍。 1. 创建并设置一个私有的Spec RepoSpec Repo是所有Pods的一个索引，相当于一个容器，所有的Pods都在这个索引里面。如 ~/CocoaPods/Specs是所有公共的Pods的索引，稍后我们创建BWTSpecs就是我们所有Pods私有库的索引。 接下来我们创建Spec Repo，在终端执行以下命令： 1pod repo add BWTSpecs http://git.bwton.com/msx-client-ios/BWTSpecs.git http://git.bwton.com/msx-client-ios/BWTSpecs.git 是我们创建好的存放BWTSpecs索引的仓库。 成功之后在~/.cocoapods/repos目录下会多出一个BWTSpecs文件。第一步完成。 PS:多人开发时，其他成员也需要执行这个命令，且其他成员需要有这个Git仓库的权限。 2. 创建Pod所需要的项目工程文件在终端进入需要创建项目的目录，然后执行： 1pod lib create BWTKit 执行完之后会有几个问题，按需要回答即可。回答完之后会自动执行pod install命令创建项目并生成依赖。 现在进入到项目目录下的Example目录下，打开workspace文件，删掉Replaceme文件，开始编辑BWTKit.podspec文件，参考以下格式： 1234567891011121314Pod::Spec.new do |s| s.name = &apos;BWTKit&apos; s.version = &apos;1.0.0&apos; s.summary = &apos;八维通基础业务模块&apos; s.description = &lt;&lt;-DESC ‘该模块主要处理码上行App中基础业务相关.’ DESC s.homepage = &apos;http://git.bwton.com&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;xujiebing&apos; =&gt; &apos;xujiebing1992@gmail.com&apos; &#125; s.source = &#123; :git =&gt; &apos;http://git.bwton.com/msx-client-ios/BWTKit.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;BWTKit/*&apos; end 添加项目需要的代码，本地先测试编译，确保编译通过。 3. 向远程仓库提交工程项目在终端中进入BWTKit目录 将本地工程文件提交到远程仓库。执行以下命令： 1234git add . git commit -m &apos;初始化项目&apos; git remote add origin http://git.bwton.com/msx-client-ios/BWTKit.git # 关联远程仓库 git push origin master # 提交到远程仓库 PS：如果push失败可以尝试命令：git push origin master -f # 覆盖远程仓库 podspec文件中需要获取Git的tag，所以我们这里需要打上tag。执行以下命令： 12git tag -m &apos;第一个tag&apos; 1.0.0 git push --tags # 推送tag到远程仓库 4. 向私有的Spec Repo中提交podspec在终端中进入BWTKit目录 先本地验证podspec文件，执行命令： 1pod lib lint 当看到以下输出表示本地验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 接下来进行远程验证，执行命令： 1pod spec lint 当看到以下输出表示远程验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 验证完之后向远程BWTSpecs提交podspec，执行命令： 1pod repo push BWTSpecs BWTKit.podspec 完成之后这个BWTKit库就添加到我们的私有BWTSpecs中了，可以进入到~/.cocoapods/repos/BWTSpecs目录下查看，也可以去远程仓库查看。 5. 在个人项目中引入私有库在需要引入私有库的项目的podfile文件中引入： 123source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; pod &apos;BWTKit&apos;, &apos;~&gt; 1.0.0&apos; PS: source ‘https://github.com/CocoaPods/Specs.git&#39; 必须要加，否则项目中引入的共有的Pods库将无法安装 6. 更新维护podspec我们已经制作好BWTKit 1.0.0版本，现在业务有变更，需要对BWTKit进行升级。 这是只需要将2，3，4，5步中的version和tag设置成新的值，然后重复2，3，4，5步即可。 二.远程私有库中引入私有库以BWTBaseBiz引入BWTKit为例 1. 创建Pod所需要的项目工程文件在终端进入需要创建项目的目录，然后执行： 1pod lib create BWTBaseBiz 执行完之后会有几个问题，按需要回答即可。回答完之后会自动执行pod install命令创建项目并生成依赖。 现在进入到项目目录下的Example目录下，打开workspace文件，删掉Replaceme文件，开始编辑BWTBaseBiz.podspec文件，参考以下格式： 123456789101112131415Pod::Spec.new do |s| s.name = &apos;BWTBaseBiz&apos; s.version = &apos;1.0.0&apos; s.summary = &apos;八维通基础业务模块&apos; s.description = &lt;&lt;-DESC ‘该模块主要处理码上行App中基础业务相关.’ DESC s.homepage = &apos;http://git.bwton.com&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;xujiebing&apos; =&gt; &apos;xujiebing1992@gmail.com&apos; &#125; s.source = &#123; :git =&gt; &apos;http://git.bwton.com/msx-client-ios/BWTBaseBiz.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;BWTBaseBiz/*&apos; s.dependency &apos;BWTKit&apos; # 注意：这一步比较关键 end 在Podfile中加入：# 注意：这一步有所区别 12source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; 进入Example目录下执行 pod install 添加项目需要的代码，本地先测试编译，确保编译通过。 2. 向远程仓库提交工程项目在终端中进入BWTBaseBiz目录 将本地工程文件提交到远程仓库。执行以下命令： 1234git add . git commit -m &apos;初始化项目&apos; git remote add origin http://git.bwton.com/msx-client-ios/BWTBaseBiz.git # 关联远程仓库 git push origin master # 提交到远程仓库 PS：如果push失败可以尝试命令：git push origin master -f # 覆盖远程仓库 podspec文件中需要获取Git的tag，所以我们这里需要打上tag。执行以下命令： 12git tag -m &apos;第一个tag&apos; 1.0.0 git push --tags # 推送tag到远程仓库 3. 向私有的Spec Repo中提交podspec在终端中进入BWTKit目录 先本地验证podspec文件，执行命令：# 注意：这一步有区别 1pod lib lint --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 当看到以下输出表示本地验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 接下来进行远程验证，执行命令：# 注意：这一步有区别 1pod spec lint --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 当看到以下输出表示远程验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 验证完之后向远程BWTSpecs提交podspec，执行命令：# 注意：这一步有区别 1pod repo push BWTSpecs BWTKit.podspec --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 完成之后这个BWTKit库就添加到我们的私有BWTSpecs中了，可以进入到~/.cocoapods/repos/BWTSpecs目录下查看，也可以去远程仓库查看。私有库引入私有库制作完毕。 4. 在个人项目中引入私有库在需要引入私有库的项目的podfile文件中引入： 123source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; pod &apos;BWTBaseBiz&apos;, &apos;~&gt; 1.0.0&apos; 这时BWTKit和BWTBaseBiz都会被引入到项目中 三.更新私有库搜索不到远程私有库时，可以执行以下操作： 1.进入终端执行命令： 1rm ~/Library/Caches/CocoaPods/search_index.json 2.进入到本地索引文件目录~/.cocoapods/repos/BWTSpecs下执行命令： 1git pull 接着搜索私有库即可搜到 四.如何删除私有库1. 删除整个BWTSpecs文件，执行命令：1pod repo remove BWTSpecs 这样本地的就删除了，还可以通过以下命令加回来： 1pod repo add BWTSpecs http://git.bwton.com/msx-client-ios/BWTSpecs.git 2. 删除某个私有库进入目录 ~/.cocoapods/repos/BWTSpecs下,删除私有库目录，执行命令： 1rm -Rf BWTKit 然后将本地的修改推到远程库，执行命令： 123git add -A git commit -m &apos;删除BWTKit私有库&apos; git push origin master 操作完毕","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xujiebing.github.io/categories/开发工具/"}],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://xujiebing.github.io/tags/CocoaPods/"}]},{"title":"iOS SHA1WithRSA加签验签","slug":"iOS-SHA1WithRSA加签验签","date":"2019-06-22T14:55:41.000Z","updated":"2019-06-22T14:56:59.486Z","comments":true,"path":"2019/06/22/iOS-SHA1WithRSA加签验签/","link":"","permalink":"https://xujiebing.github.io/2019/06/22/iOS-SHA1WithRSA加签验签/","excerpt":"","text":"这篇文章主要介绍一点关于SHA1WithRSA的干货以及本人在开发的过程中遇到的坑 干货下载链接 关于RSA相关介绍、对称加密与非对称加密、公私钥、加密解密以及加签验签请自行百度 本人在项目中遇到的问题： 问题一：App加签之后的数据在服务端无法验签 问题描述：本人在项目中对使用的AFNetworking，并拦截了BWTAFHTTPRequestSerializer中的requestBySerializingRequest:withParameters:error:方法，将请求的包体转成json字符串进行加签，然后将加签信息作为签名放在请求头中上传到服务器，服务器验签失败 解决过程：开始怀疑是算法出了问题，网上查找资料，发现算法跟我项目中的基本是一致的，后来又是查找资料也没有解决。后来在断点调试中发现requestBySerializingRequest:withParameters:error: 中的query(AFNetworking中将包体转成json字符串，即query)变量与包体转成的json字符串不一样，于是瞬间豁然开朗，问题解决，over。 问题分析： 首先，我们先回忆一下加签验签的过程： 我们将A字符串用私钥加签，得到sign字符串；然后用公钥、A字符串和sign进行验签。说到这里大家应该明白了query变量和包体的json字符串不一样为什么会导致服务端验签不通过了。 项目中是将包体转成json字符串，使用到了MJExtension中的方法，转换出来的字符串不知道为什么多出了n和空格，这就导致我们加签的明文和服务端验签的明文(明文为query比变量)不一致(哪怕是多出一个空格也不行)，导致服务端验签失败。 问题找到了，怎么解决就不再啰嗦了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://xujiebing.github.io/categories/iOS/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xujiebing.github.io/tags/算法/"}]},{"title":"UIImageView的contentModel、裁剪、layer属性以及局部拉伸详解","slug":"UIImageView的contentModel、裁剪、layer属性以及局部拉伸详解","date":"2019-06-22T14:46:29.000Z","updated":"2019-06-22T14:56:30.197Z","comments":true,"path":"2019/06/22/UIImageView的contentModel、裁剪、layer属性以及局部拉伸详解/","link":"","permalink":"https://xujiebing.github.io/2019/06/22/UIImageView的contentModel、裁剪、layer属性以及局部拉伸详解/","excerpt":"","text":"在我们开发过程中，UIImageView是一个使用频率相对较高的控件。那么对该控件做一个全面的认识，会对我们业务开发起到十分重要的作用。这篇文章主要讲解UIImageView的contentMode属性和图片的裁剪关系，layer属性以及图片的局部拉伸。 Demo链接 contentMode该属性是UIView的属性，表示view内容的填充样式，不同属性的值的效果可参考demo 。contentModel一共有13种填充模式，分别是： UIViewContentModeScaleToFill 这是图片显示的默认模式。图片进行非等比例缩放，直到填铺满整个View区域。所以往往造成图片的变形。也就是图片的长度上缩放一定的比例填满显示区域，在宽度上缩放一定的比例填满显示区域。 UIViewContentModeScaleAspectFit 这是等比例缩放，所以使用这种缩放模式的图片永远不会变形。图片按一定比例缩放，直到在长度上或者宽度上达到View的边界就停止。没有填满区域就显示View的背景。 UIViewContentModeScaleAspectFill 这也是等比例缩放，图片也不会变形。这种缩放和上面的ScaleAspectFit正好相反，图片按一定比例缩放，直到最短的边达到View的边界。所以这种缩放一定会铺满View，超出View的图片你可以选择截掉或者不截掉。 UIViewContentModeRedraw 重绘。该模式比较特别，它不是用来说明如何展示图片的，而是告诉视图在每次设置或者更改frame的时候自动调用drawRect：方法 UIViewContentModeCenter 等比缩放，居中显示。 UIViewContentModeTop 等比缩放，顶部对齐显示。 UIViewContentModeBottom 等比缩放，底部对齐显示。 UIViewContentModeLeft 等比缩放，左侧对齐显示。 UIViewContentModeRight 等比缩放，右侧对齐显示。 UIViewContentModeTopLeft 等比缩放，左上角对齐显示。 UIViewContentModeTopRight 等比缩放，右上角对齐显示。 UIViewContentModeBottomLeft 等比缩放，左下角对齐显示。 UIViewContentModeBottomRight 等比缩放，右下角对齐显示。 contentModel与图片裁剪通过demo效果，我们发现contentModel也可以实现裁剪功能。那么普通的裁剪方法跟contentModel属性有什么区别，我们可以通过demo来观察。 layer属性的简单介绍 layer是UIView的一个属性，属于CALayer。CALayer可以在以后专门做一个专题来分享，这里只是对layer做个简单的介绍。 可以通过设置UIView的CALayer实现阴影、边框、圆角和透明等效果 CALayer没有处理事件响应的接口 UIView主要实现UI视觉上的管理，CALayer主要实现UI内容的绘制 图片的局部拉伸根据不同的业务需求，contentModel以及图片裁剪已经不能满足业务需求，这时候局部拉伸就能发挥作用了。 -(UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets; 该方法是图片的局部拉伸方法。UIEdgesets是设置图片拉伸区域距离图片的顶部、左部、下部、有部的距离。例如，一个50*50像素的图片，UIEdgeInsets全部设置为5，表示对图片中间40 * 40的区域进行拉伸。效果参考demo。 Android的ImageView的相关属性scaleType属性，控制图片缩放或移动 属性值说明 center无缩放，按原图大小显示图片，当图片宽高大于View的宽高时，截取图片中间部分显示 centerCrop按比例拉伸原图直至于填充满View宽高，并显示在View的中间。 centerInside当View的宽高&gt;=图片的宽高时，图片居中显示原大小反之将原图按比例缩放至View的宽高居中显示。 fitCenter按比例拉伸原图直至等于View某边的宽高，且显示在View的中间 fitStart按比例拉伸图片，且显示在View的左上边 fitEnd按比例拉伸图片，且显示在View的右下边 fitXY拉伸图片（不按比例）以填充View的宽高 matrix用矩阵来绘图 tint属性，为图片设置渲染颜色，单独设置时，会覆盖掉原有背景图片","categories":[{"name":"iOS","slug":"iOS","permalink":"https://xujiebing.github.io/categories/iOS/"}],"tags":[{"name":"UI","slug":"UI","permalink":"https://xujiebing.github.io/tags/UI/"}]},{"title":"Xcode导出ipa文件时四种类型说明","slug":"Xcode导出ipa文件时四种类型说明","date":"2019-06-21T11:45:19.000Z","updated":"2019-06-24T14:12:27.041Z","comments":true,"path":"2019/06/21/Xcode导出ipa文件时四种类型说明/","link":"","permalink":"https://xujiebing.github.io/2019/06/21/Xcode导出ipa文件时四种类型说明/","excerpt":"","text":"在 iOS 导出 ipa包的时候 会有四个选项： Save for iOS App Store Deployment 保存到本地 准备上传App Store 或者在越狱的iOS设备上使用 Save for Ad Hoc Deployment 保存到本地 准备在账号添加的可使用设备上使用（具体为在开发者账户下添加可用设备的udid），该app包是发布证书编译的（The app will be code signed with the distribution certificate.） Save for Enterprise Deployment 这种主要针对企业级账户下 准备本地服务器分发的app Save for Development Deployment 针对内部测试使用，主要给开发者的设备(具体也为在开发者账户下添加可用设备的udid)。该app包是开发证书编译的（The app will be code signed with your development certificate）","categories":[{"name":"iOS","slug":"iOS","permalink":"https://xujiebing.github.io/categories/iOS/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://xujiebing.github.io/tags/Xcode/"}]},{"title":"Mac安全性与隐私设置","slug":"Mac安全性与隐私设置","date":"2019-06-21T11:33:36.000Z","updated":"2019-06-22T08:02:40.545Z","comments":true,"path":"2019/06/21/Mac安全性与隐私设置/","link":"","permalink":"https://xujiebing.github.io/2019/06/21/Mac安全性与隐私设置/","excerpt":"","text":"Mac中安装非AppStore下载的应用时经常会软件已损坏，无法安装的情况。这是需要在安全性与隐私中设置允许任何来源 打开终端 执行命令 1sudo spctl --master-disable 打开安全设置选项，就会发现「任何来源」选项回来了 PS:其实对于升级系统前，已经是任何来源选项的，还会显示，不会改变，但别的选项的，升级后就会消失.","categories":[{"name":"Mac相关","slug":"Mac相关","permalink":"https://xujiebing.github.io/categories/Mac相关/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://xujiebing.github.io/tags/Mac/"}]},{"title":"不花钱的百度网盘SVIP","slug":"不花钱的百度网盘SVIP","date":"2019-06-21T09:10:44.000Z","updated":"2019-06-21T11:48:19.970Z","comments":true,"path":"2019/06/21/不花钱的百度网盘SVIP/","link":"","permalink":"https://xujiebing.github.io/2019/06/21/不花钱的百度网盘SVIP/","excerpt":"","text":"百度网盘非SVIP下载网速受限，上传文件大小受限怎么办？ 充会员，那是不可能的，哈哈！ 敲黑板，划重点 macOS上先安装好百度网盘 登录账号 执行脚本 1cd ~/Downloads &amp;&amp; git clone https://github.com/CodeTips/BaiduNetdiskPlugin-macOS.git &amp;&amp; ./BaiduNetdiskPlugin-macOS/Other/[Install.sh] 打开百度网盘，开始享受SVIP吧","categories":[{"name":"Mac相关","slug":"Mac相关","permalink":"https://xujiebing.github.io/categories/Mac相关/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://xujiebing.github.io/tags/Mac/"}]}]}