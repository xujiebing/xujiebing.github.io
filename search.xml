<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基础算法之字符串类]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[字符串翻转给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 输入: “Let’s take LeetCode contest”输出: “s’teL ekat edoCteeL tsetnoc” 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 1234567function revertWords(string) &#123; let array = string.split(' ') let result = array.map(item =&gt; &#123; return item.split('').reverse().join('') &#125;) return result.join(' ')&#125; 计算二进制子串给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1是组合在一起的。重复出现的子串要计算它们出现的次数。 示例 1 : 输入: “00110011”输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 1234567891011121314151617181920function subStringArray(string) &#123; let x = string.split(&apos;0&apos;).length - 1 let y = string.split(&apos;1&apos;).length - 1 let length = x &gt; y ? y : x var subArray = [] for (var i = 1; i &lt;= length; i++) &#123; subArray.push(&apos;0&apos;.repeat(i) + &apos;1&apos;.repeat(i)) subArray.push(&apos;1&apos;.repeat(i) + &apos;0&apos;.repeat(i)) &#125; var result = [] subArray.map(item =&gt; &#123; let count = string.split(item).length if (count &gt; 1) &#123; for (var i = 1; i &lt; count; i++) &#123; result.push(item) &#125; &#125; &#125;) return result;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用RunLoop监控卡顿]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%88%A9%E7%94%A8RunLoop%E7%9B%91%E6%8E%A7%E5%8D%A1%E9%A1%BF%2F</url>
    <content type="text"><![CDATA[导致卡顿的原因 复杂 UI 、图文混排的绘制量过大； 在主线程上做网络同步请求； 在主线程做大量的 IO 操作； 运算量过大，CPU 持续高占用； 死锁和主子线程抢锁。 RunLoop原理RunLoop 是 iOS 开发中的一个基础概念，为了帮助你理解并用好这个对象，接下来我会先和你介绍一下它可以做哪些事儿，以及它为什么可以做成这些事儿。 RunLoop 这个对象，在 iOS 里由 CFRunLoop 实现。简单来说，RunLoop 是用来监听输入源，进行调度处理的。这里的输入源可以是输入设备、网络、周期性或者延迟时间、异步回调。RunLoop 会接收两种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息；另一种是来自预订时间或者重复间隔的同步事件。 RunLoop 的目的是，当有事件要去处理时保持线程忙，当没有事件要处理时让线程进入休眠。所以，了解 RunLoop 原理不光能够运用到监控卡顿上，还可以提高用户的交互体验。通过将那些繁重而不紧急会大量占用 CPU 的任务（比如图片加载），放到空闲的 RunLoop 模式里执行，就可以避开在 UITrackingRunLoopMode 这个 RunLoop 模式时是执行。UITrackingRunLoopMode 是用户进行滚动操作时会切换到的 RunLoop 模式，避免在这个 RunLoop 模式执行繁重的 CPU 任务，就能避免影响用户交互操作上体验。 RunLoop执行原理 通知 observers：RunLoop 要开始进入 loop 了。紧接着就进入 loop。 开启一个 do while 来保活线程。通知 Observers：RunLoop 会触发 Timer 回调、Source0 回调，接着执行加入的 block。 回调触发后，通知 Observers：RunLoop 的线程将进入休眠（sleep）状态。 进入休眠后，会等待 mach_port 的消息，以再次唤醒。只有在下面四个事件出现时才会被再次唤醒： 基于 port 的 Source 事件； Timer 时间到； RunLoop 超时； 被调用者唤醒。 唤醒时通知 Observer：RunLoop 的线程刚刚被唤醒了。 RunLoop 被唤醒后就要开始处理消息了： 如果是 Timer 时间到的话，就触发 Timer 的回调； 如果是 dispatch 的话，就执行 block； 如果是 source1 事件的话，就处理这个事件。 消息执行完后，就执行加到 loop 里的 block。 根据当前 RunLoop 的状态来判断是否需要走下一个 loop。当被外部强制停止或 loop 超时时，就不继续下一个 loop 了，否则继续走下一个 loop 。 整个过程示意图]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 崩溃千奇百怪，如何全面监控]]></title>
    <url>%2F2019%2F08%2F06%2FiOS-%E5%B4%A9%E6%BA%83%E5%8D%83%E5%A5%87%E7%99%BE%E6%80%AA%EF%BC%8C%E5%A6%82%E4%BD%95%E5%85%A8%E9%9D%A2%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[常见的崩溃情况 数组越界：在取数据索引时越界，App 会发生崩溃。还有一种情况，就是给数组添加了 nil 会崩溃。 多线程问题：在子线程中进行 UI 更新可能会发生崩溃。多个线程进行数据的读取操作，因为处理时机不一致，比如有一个线程在置空数据的同时另一个线程在读取这个数据，可能会出现崩溃情况。 主线程无响应：如果主线程超过系统规定的时间无响应，就会被 Watchdog 杀掉。这时，崩溃问题对应的异常编码是 0x8badf00d。关于这个异常编码，我还会在后文和你说明。 野指针：指针指向一个已删除的对象访问内存区域时，会出现野指针崩溃。野指针问题是需要我们重点关注的，因为它是导致 App 崩溃的最常见，也是最难定位的一种情况。 常见的崩溃情况分类信号可捕获的分类 KVO问题 NSNotification线程问题 数组越界 野指针等 信号不可捕获的分类 后台任务超时 内存打爆 主线程卡顿超阈值等 信号可捕获的崩溃信息收集崩溃监控工具 PLCrashReporter Fabric Bugly 将崩溃时获取到的崩溃信息保存本地，下次打开App是上传崩溃信息 信号不可捕获的崩溃信息收集后台容易崩溃的原因是什么？先介绍下 iOS 后台保活的 5 种方式：Background Mode、Background Fetch、Silent Push、PushKit、Background Task。 使用 Background Mode 方式的话，App Store 在审核时会提高对 App 的要求。通常情况下，只有那些地图、音乐播放、VoIP 类的 App 才能通过审核。 Background Fetch 方式的唤醒时间不稳定，而且用户可以在系统里设置关闭这种方式，导致它的使用场景很少。 Silent Push 是推送的一种，会在后台唤起 App 30 秒。它的优先级很低，会调用 application:didReceiveRemoteNotifiacation:fetchCompletionHandler: 这个 delegate，和普通的 remote push notification 推送调用的 delegate 是一样的。 PushKit 后台唤醒 App 后能够保活 30 秒。它主要用于提升 VoIP 应用的体验。 Background Task 方式，是使用最多的。App 退后台后，默认都会使用这种方式。 在你的程序退到后台以后，只有几秒钟的时间可以执行代码，接下来就会被系统挂起。进程挂起后所有线程都会暂停，不管这个线程是文件读写还是内存读写都会被暂停。但是，数据读写过程无法暂停只能被中断，中断时数据读写异常而且容易损坏文件，所以系统会选择主动杀掉 App 进程。 而 Background Task 这种方式，就是系统提供了 beginBackgroundTaskWithExpirationHandler 方法来延长后台执行时间，可以解决你退后台后还需要一些时间去处理一些任务的诉求。 如何避免后台崩溃呢？App 退后台后，如果执行时间过长就会导致被系统杀掉。那么，如果我们要想避免这种崩溃发生的话，就需要严格控制后台数据的读写操作。比如，你可以先判断需要处理的数据的大小，如果数据过大，也就是在后台限制时间内或延长后台执行时间后也处理不完的话，可以考虑在程序下次启动或后台唤醒时再进行处理。 同时，App 退后台后，这种由于在规定时间内没有处理完而被系统强制杀掉的崩溃，是无法通过信号被捕获到的。这也说明了，随着团队规模扩大，要想保证 App 高可用的话，后台崩溃的监控就尤为重要了。 怎么去收集退后台后超过保活阈值而导致信号捕获不到的那些崩溃信息呢？ 采用 Background Task 方式时，我们可以根据 beginBackgroundTaskWithExpirationHandler 会让后台保活 3 分钟这个阈值，先设置一个计时器，在接近 3 分钟时判断后台程序是否还在执行。如果还在执行的话，我们就可以判断该程序即将后台崩溃，进行上报、记录，以达到监控的效果。 还有哪些信号捕获不到的崩溃情况？怎样监控其他无法通过信号捕获的崩溃信息？ 其他捕获不到的崩溃情况还有很多，主要就是内存打爆和主线程卡顿时间超过阈值被 watchdog 杀掉这两种情况。 其实，监控这两类崩溃的思路和监控后台崩溃类似，我们都先要找到它们的阈值，然后在临近阈值时还在执行的后台程序，判断为将要崩溃，收集信息并上报。 采集到崩溃信息后如何分析并解决崩溃问题呢？我们采集到的崩溃日志，主要包含的信息为：进程信息、基本信息、异常信息、线程回溯。 进程信息：崩溃进程的相关信息，比如崩溃报告唯一标识符、唯一键值、设备标识； 基本信息：崩溃发生的日期、iOS 版本； 异常信息：异常类型、异常编码、异常的线程； 线程回溯：崩溃时的方法调用栈。 通常情况下，我们分析崩溃日志时最先看的是异常信息，分析出问题的是哪个线程，在线程回溯里找到那个线程；然后，分析方法调用栈，符号化后的方法调用栈可以完整地看到方法调用的过程，从而知道问题发生在哪个方法的调用上。 异常编码完整的崩溃日志里，除了线程方法调用栈还有异常编码。异常编码，就在异常信息里。 一些被系统杀掉的情况，我们可以通过异常编码来分析。你可以在维基百科上，查看完整的异常编码。这里列出了 44 种异常编码，但常见的就是如下三种： 0x8badf00d，表示 App 在一定时间内无响应而被 watchdog 杀掉的情况。 0xdeadfa11，表示 App 被用户强制退出。 0xc00010ff，表示 App 因为运行造成设备温度太高而被杀掉。 0x8badf00d 这种情况是出现最多的。当出现被 watchdog 杀掉的情况时，我们就可以把范围控制在主线程被卡的情况。 0xdeadfa11 的情况，是用户的主动行为，我们不用太关注。 0xc00010ff 这种情况，就要对每个线程 CPU 进行针对性的检查和优化。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipa包大小优化]]></title>
    <url>%2F2019%2F07%2F30%2Fipa%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[官方 App ThinningApp Thinning 是由苹果公司推出的一项可以改善 App 下载进程的新技术，主要是为了解决用户下载 App 耗费过高流量的问题，同时还可以节省用户 iOS 设备的存储空间。 App Thinning 有三种方式，包括：App Slicing、Bitcode、On-Demand Resources。 App Slicing，会在你向 iTunes Connect 上传 App 后，对 App 做切割，创建不同的变体，这样就可以适用到不同的设备。 On-Demand Resources，主要是为游戏多关卡场景服务的。它会根据用户的关卡进度下载随后几个关卡的资源，并且已经过关的资源也会被删掉，这样就可以减少初装 App 的包大小。 Bitcode ，是针对特定设备进行包大小优化，优化不明显。 无用图片资源删除无用图片的过程，可以概括为下面这 6 大步。 通过 find 命令获取 App 安装包中的所有资源文件，比如 find /Users/daiming/Project/ -name。 设置用到的资源的类型，比如 jpg、gif、png、webp。 使用正则匹配在源码中找出使用到的资源名，比如 pattern = @”@”(.+?)””。 使用 find 命令找到的所有资源文件，再去掉代码中使用到的资源文件，剩下的就是无用资源了。 对于按照规则设置的资源名，我们需要在匹配使用资源的正则表达式里添加相应的规则，比如 @“image_%d”。 确认无用资源后，就可以对这些无用资源执行删除操作了。这个删除操作，你可以使用 NSFileManger 系统类提供的功能来完成。 工具LSUnusedResources 图片资源压缩对于 App 来说，图片资源总会在安装包里占个大头儿。对它们最好的处理，就是在不损失图片质量的前提下尽可能地作压缩。目前比较好的压缩方案是，将图片转成 WebP。WebP 是 Google 公司的一个开源项目。 为什么选择WebP WebP 压缩率高，而且肉眼看不出差异，同时支持有损和无损两种压缩模式。比如，将 Gif 图转为 Animated WebP ，有损压缩模式下可减少 64% 大小，无损压缩模式下可减少 19% 大小。 WebP 支持 Alpha 透明和 24-bit 颜色数，不会像 PNG8 那样因为色彩不够而出现毛边。 代码瘦身App 的安装包主要是由资源和可执行文件组成的，所以我们在掌握了对图片资源的处理方式后，需要再一起来看看对可执行文件的瘦身方法。 可执行文件就是 Mach-O 文件，其大小是由代码量决定的。通常情况下，对可执行文件进行瘦身，就是找到并删除无用代码的过程。而查找无用代码时，我们可以按照找无用图片的思路，即： 首先，找出方法和类的全集； 然后，找到使用过的方法和类； 接下来，取二者的差集得到无用代码； 最后，由人工确认无用代码可删除后，进行删除即可。 通过 AppCode 找出无用代码检测结果说明 无用类：Unused class 是无用类，Unused import statement 是无用类引入声明，Unused property 是无用的属性； 无用方法：Unused method 是无用的方法，Unused parameter 是无用参数，Unused instance variable 是无用的实例变量，Unused local variable 是无用的局部变量，Unused value 是无用的值； 无用宏：Unused macro 是无用的宏。 无用全局：Unused global declaration 是无用全局声明。 AppCode 静态检查的问题： JSONModel 里定义了未使用的协议会被判定为无用协议； 如果子类使用了父类的方法，父类的这个方法不会被认为使用了； 通过点的方式使用属性，该属性会被认为没有使用； 使用 performSelector 方式调用的方法也检查不出来，比如 self performSelector:@selector(arrivalRefreshTime)； 运行时声明类的情况检查不出来。比如通过 NSClassFromString 方式调用的类会被查出为没有使用的类，比如 layerClass = NSClassFromString(@“SMFloatLayer”)。还有以 [[self class] accessToken] 这样不指定类名的方式使用的类，会被认为该类没有被使用。像 UITableView 的自定义的 Cell 使用 registerClass，这样的情况也会认为这个 Cell 没有被使用。 基于以上种种原因，使用 AppCode 检查出来的无用代码，还需要人工二次确认才能够安全删除掉。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[埋点方案实现]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用Clang为App提质]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Clang%E4%B8%BAApp%E6%8F%90%E8%B4%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC代码静态分析工具]]></title>
    <url>%2F2019%2F07%2F23%2FOC%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[简介Xcode 自带的静态分析工具 Analyze，通过静态语法分析能够找出在代码层面就能发现的内存泄露问题，还可以通过上下文分析出是否存在变量无用等问题。但是，Analyze 的功能还是有限，还是无法帮助我们在编写代码的阶段发现更多的问题。所以，这才诞生出了功能更全、定制化高、效率高的第三方静态检查工具。比如，OCLint、Infer、Clang 静态分析器等。 静态分析器可以检查代码规范和代码可维护性的问题，根据一些指标就能够找出哪些代码需要优化和重构。这里有三个常用的复杂度指标，可以帮助我们度量是否需要优化和重构代码。 圈复杂度高。 圈复杂度，指的是遍历一个模块时的复杂度，这个复杂度是由分支语句比如 if、case、while、for，还有运算符比如 &amp;&amp;、||，以及决策点，共同确定的。一般来说，圈复杂度在以 4 以内是低复杂度，5 到 7 是中复杂度，8 到 10 是高复杂度，11 以上时复杂度就非常高了，这时需要考虑重构，不然就会因为测试用例的数量过高而难以维护。而这个圈复杂度的值，是很难通过人工分析出来的。而静态分析器就可以根据圈复杂度规则，来监控圈复杂度，及时发现代码是否过于复杂，发现问题后及早解决，以免造成代码过于复杂难以维护。 NPath 复杂度高。 NPath 度量是指一个方法所有可能执行的路径数量。一般高于 200 就需要考虑降低复杂度了。 NCSS 度量高。 NCSS 度量是指不包含注释的源码行数，方法和类过大会导致代码维护时阅读困难，大的 NCSS 值表示方法或类做的事情太多，应该拆分或重构。一般方法行数不过百，类的行数不过千。 但是，使用静态分析技术来保证工程质量，也并不尽如人意，还有如下两大缺陷： 需要耗费更长的时间。 相比于编译过程，使用静态分析技术发现深层次程序错误时，会对当前分析的方法、参数、变量去和整个工程关联代码一起做分析。所以，随着工程代码量的增加，每一步分析所依赖的影响面都会增大，所需耗时就更长。 虽然我们在设计静态分析器时，就已经对其速度做了很多优化，但还是达不到程序编译的速度。因为静态分析本身就包含了编译最耗时的 IO 和语法分析阶段，而且静态分析的内容多于编译，所以再怎么优化，即使是最好的情况也会比编译过程来得要慢。 静态分析器只能检查出那些专门设计好的、可查找的错误。 对于特定类型的错误分析，还需要开发者靠自己的能力写一些插件并添加进去。 好了，现在我们已经了解了静态分析器的优缺点，那么面对繁多的 iOS 的静态代码检查工具，我们到底应该选择哪一个呢？ OCLintOCLint 是基于 Clang Tooling 开发的静态分析工具，主要用来发现编译器检查不到的那些潜在的关键技术问题。2017 年 9 月份新发布的 OCLint 0.13 版本中，包含了 71 条规则。 这些规则已经基本覆盖了具有通用性的规则，主要包括语法上的基础规则、Cocoa 库相关规则、一些约定俗成的规则、各种空语句检查、是否按新语法改写的检查、命名上长变量名短变量名检查、无用的语句变量和参数的检查。 除此之外，还包括了和代码量大小是否合理相关的一些规则，比如过大的类、类里方法是否太多、参数是否过多、Block 嵌套是否太深、方法里代码是否过多、圈复杂度的检查等。 Clang 静态分析器Clang 静态分析器（Clang Static Analyzer）是一个用 C++ 开发的，用来分析 C、C++ 和 Objective-C 的开源工具，是 Clang 项目的一部分，构建在 Clang 和 LLVM 之上。Clang 静态分析器的分析引擎用的就是 Clang 的库。 Clang 静态分析器专门为速度做过优化，可以在保证查出错误的前提下，使用更聪明的算法减少检查的工作量。 InferInfer 是 Facebook 开源的、使用 OCaml 语言编写的静态分析工具，可以对 C、Java 和 Objective-C 代码进行静态分析，可以检查出空指针访问、资源泄露以及内存泄露。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App如何实现极速编译调试]]></title>
    <url>%2F2019%2F07%2F18%2FApp%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[虽然动态链接器的实际应用能够帮助我们缩短App编译时间，但是每次修改代码之后还是需要重新启动App，再走一遍调试流程。对于我们开发人员来说，提高编译调试的速度就是提高生产力。那么，目前有哪些工具是可以实现动态调试的呢？ Swift PlaygroundPlayground是 Xcode 里集成的一个能够快速、实时调试程序的工具，可以实现所见即所得的效果，如下图所示： Flutter Hot ReloadFlutter 是 Google 开发的一个跨平台开发框架，调试也是快速实时的。官方的效果动画如下： Injection for XcodeInjection 的工具可以动态地将 Swift 或 Objective-C 的代码在已运行的程序中执行，以加快调试速度，同时保证程序不用重启。John Holdsworth 也提供了动画演示效果，如下： Injection工作原理 Injection 会监听源代码文件的变化，如果文件被改动了，Injection Server 就会执行 rebuildClass 重新进行编译、打包成动态库，也就是 .dylib 文件。编译、打包成动态库后使用 writeSting 方法通过 Socket 通知运行的 App。 Server 会在后台发送和监听 Socket 消息，实现逻辑在 InjectionServer.mm 的 runInBackground 方法里。Client 也会开启一个后台去发送和监听 Socket 消息，实现逻辑在 InjectionClient.mm里的 runInBackground 方法里。 Client 接收到消息后会调用 inject(tmpfile: String) 方法，运行时进行类的动态替换。inject(tmpfile: String) 方法的代码大部分都是做新类动态替换旧类。inject(tmpfile: String) 的入参 tmpfile 是动态库的文件路径，那么这个动态库是如何加载到可执行文件里的呢？具体的实现在 inject(tmpfile: String) 方法开始里。 dlopen 会把 tmpfile 动态库文件载入运行的 App 里，返回指针 dl。接下来，dlsym 会得到 tmpfile 动态库的符号地址，然后就可以处理类的替换工作了。当类的方法都被替换后，我们就可以开始重新绘制界面了。整个过程无需重新编译和重启 App，至此使用动态库方式极速调试的目的就达成了。 Injection源码 InjectionIII使用方法 从AppStore下载InjectionIII 设置AppDelegate.m 打开你的源码，在AppDelegate.m的didFinishLaunchingWithOptions方法添加一行代码： 1234#if DEBUG // iOS [[NSBundle bundleWithPath:@&quot;/Applications/InjectionIII.app/Contents/Resources/iOSInjection.bundle&quot;] load];#endif 设置ViewController 在需要修改界面的ViewController添加方法，所有修改控件的代码都写在这里面。 12- (void)injected &#123;&#125; 设置InjectionIII 打开InjectionIII工具，选择Open Project，选择你的代码所在的路径，然后点击Select Project Directory保存。 注意：InjectionIII 的File Watcher选项要保持选中状态 运行项目 按照第4步选择完项目路径后，先在Xcode Command+R运行一下你的项目，控制台提示如下信息，即表示InjectionIII连接成功，连接成功的话InjectionIII标志会由蓝变橙（可能不同InjectionIII版本颜色不太一样）。 控制台提示信息 连接成功后，就可以在第3步中的- (void)injected;方法中修改控件、添加控件了，修改完毕Command+S保存一下代码，立刻就在模拟器上显示修改的信息了。 需要注意的两点： InjectionIII工具只对模拟器有效，真机无效。 在injected方法里面修改的代码，再次Command+R运行时不会起作用。因为代码里面只声明了injected方法，并没有去调用，所以不会生效；我们Command+S保存代码后生效，是因为在保存后通过InjectionIII工具读取injected方法里面修改的代码，“告诉”模拟器哪儿修改了，是InjectionIII起的作用。因此我们需要把修改的代码放到合适的位置，让程序一运行就会执行。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链接器：符号是怎么绑定到地址上的]]></title>
    <url>%2F2019%2F07%2F16%2F%E9%93%BE%E6%8E%A5%E5%99%A8%EF%BC%9A%E7%AC%A6%E5%8F%B7%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%91%E5%AE%9A%E5%88%B0%E5%9C%B0%E5%9D%80%E4%B8%8A%E7%9A%84%2F</url>
    <content type="text"><![CDATA[链接器最主要的作用，就是将符号绑定到地址上 iOS 开发为什么使用的是编译器？iOS 编写的代码是先使用编译器把代码编译成机器码，然后直接在 CPU 上执行机器码的。之所以不使用解释器来运行代码，是因为苹果公司希望 iPhone 的执行效率更高、运行速度能达到最快。 为什么说用解释器运行代码的速度不够快呢？ 因为解释器会在运行时解释执行代码，获取一段代码后就会将其翻译成目标代码（就是字节码（Bytecode）），然后一句一句地执行目标代码。 也就是说，解释器，是在运行时才去解析代码，这样就比在运行之前通过编译器生成一份完整的机器码再去执行的效率要低。 优点 缺点 编译器 1.效率高2.运行速度快 1.调试周期长 解释器 1.调试方便2.缩短开发周期和功能更新周期 1.执行效率低 iOS 开发使用的到底是什么编译器现在苹果公司使用的编译器是 LLVM，相比于 Xcode 5 版本前使用的 GCC，编译速度提高了 3 倍。同时，苹果公司也反过来主导了 LLVM 的发展，让 LLVM 可以针对苹果公司的硬件进行更多的优化。 LLVM 是编译器工具链技术的一个集合。而其中的 lld 项目，就是内置链接器。编译器会对每个文件进行编译，生成 Mach-O（可执行文件）；链接器会将项目中的多个 Mach-O 文件合并成一个。 编译的几个主要过程： 首先，你写好代码后，LLVM 会预处理你的代码，比如把宏嵌入到对应的位置。 预处理完后，LLVM 会对代码进行词法分析和语法分析，生成 AST 。 AST 是抽象语法树，结构上比代码更精简，遍历起来更快，所以使用 AST 能够更快速地进行静态检查，同时还能更快地生成 IR（中间表示）。 最后 AST 会生成 IR，IR 是一种更接近机器码的语言，区别在于和平台无关，通过 IR 可以生成多份适合不同平台的机器码。对于 iOS 系统，IR 生成的可执行文件就是 Mach-O。 编译时链接器做了什么Mach-O 文件里面的内容，主要就是代码和数据：代码是函数的定义；数据是全局变量的定义，包括全局变量的初始值。不管是代码还是数据，它们的实例都需要由符号将其关联起来。 为什么呢？因为 Mach-O 文件里的那些代码，比如 if、for、while 生成的机器指令序列，要操作的数据会存储在某个地方，变量符号就需要绑定到数据的存储地址。你写的代码还会引用其他的代码，引用的函数符号也需要绑定到该函数的地址上。 而链接器的作用，就是完成变量、函数符号和其地址绑定这样的任务。而这里我们所说的符号，就可以理解为变量名和函数名。 项目中Mach-O文件的合并链接器为什么还要把项目中的多个 Mach-O 文件合并成一个？ 你肯定不希望一个项目是在一个文件里从头写到尾的吧。项目中文件之间的变量和接口函数都是相互依赖的，所以这时我们就需要通过链接器将项目中生成的多个 Mach-O 文件的符号和地址绑定起来。 没有这个绑定过程的话，单个文件生成的 Mach-O 文件是无法正常运行起来的。因为，如果运行时碰到调用在其他文件中实现的函数的情况时，就会找不到这个调用函数的地址，从而无法继续执行。 链接器在链接多个目标文件的过程中，会创建一个符号表，用于记录所有已定义的和所有未定义的符号。链接时如果出现相同符号的情况，就会出现“ld: dumplicate symbols”的错误信息；如果在其他目标文件里没有找到符号，就会提示“Undefined symbols”的错误信息。 链接器对代码主要做了哪几件事儿 去项目文件里查找目标代码文件里没有定义的变量。 扫描项目中的不同文件，将所有符号定义和引用地址收集起来，并放到全局符号表中。 计算合并后长度及位置，生成同类型的段进行合并，建立绑定。 对项目中不同文件里的变量进行地址重定位。 动态库链接 静态库 静态库是编译时链接的库，需要链接进你的 Mach-O 文件里，如果需要更新就要重新编译一次，无法动态加载和更新 动态库 动态库是运行时链接的库，使用 dyld 就可以实现动态加载 Mach-O 文件是编译后的产物，而动态库在运行时才会被链接，并没参与 Mach-O 文件的编译和链接，所以 Mach-O 文件中并没有包含动态库里的符号定义。也就是说，这些符号会显示为“未定义”，但它们的名字和对应的库的路径会被记录下来。运行时通过 dlopen 和 dlsym 导入动态库时，先根据记录的库路径找到对应的库，再通过记录的名字符号找到绑定的地址。 dlopen 会把共享库载入运行进程的地址空间，载入的共享库也会有未定义的符号，这样会触发更多的共享库被载入。dlopen 也可以选择是立刻解析所有引用还是滞后去做。dlopen 打开动态库后返回的是引用的指针，dlsym 的作用就是通过 dlopen 返回的动态库指针和函数符号，得到函数的地址然后使用。 使用 dyld 加载动态库，有两种方式：有程序启动加载时绑定和符号第一次被用到时绑定。为了减少启动时间，大部分动态库使用的都是符号第一次被用到时再绑定的方式。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计合理的架构]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%AE%BE%E8%AE%A1%E5%90%88%E7%90%86%E7%9A%84%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[简单架构向大型项目架构演进中，解决三个问题，即：模块粒度应该如何划分？如何分层？多团队如何协作？而在这其中，模块粒度的划分是架构设计中非常关键的一步。同时，这也是一个细活，我们最好可以在不同阶段采用不同的粒度划分模块。 模块粒度应该怎么划分模块划分为什么要遵循原则项目规模变大后，模块划分必须遵循一定的原则。如果模块划分规则不规范、不清晰，就会导致代码耦合严重的问题，并加大架构重构的难度。这些问题主要表现在： 业务需求不断，业务开发不能停。重新划分模块的工作量越大，成本越高，重构技改需求排上日程的难度也就越大。 老业务代码年久失修，没有注释，修改起来需要重新梳理逻辑和关系，耗时长。 模块划分原则对于 iOS 这种面向对象编程的开发模式来说，我们应该遵循以下五个原则，即 SOLID 原则。 单一功能原则：对象功能要单一，不要在一个对象里添加很多功能。 开闭原则：扩展是开放的，修改是封闭的。 里氏替换原则：子类对象是可以替代基类对象的。 接口隔离原则：接口的用途要单一，不要在一个接口上根据不同入参实现多个功能。 依赖反转原则：方法应该依赖抽象，不要依赖实例。iOS 开发就是高层业务方法依赖于协议。 同时，遵守这五个原则是开发出容易维护和扩展的架构的基础。 选择合适的模块粒度iOS 开发中的组件，不是 UI 的控件，也不是 ViewController 这种大 UI 和功能的集合。因为，UI 控件的粒度太小，而页面的粒度又太大。iOS 组件，应该是包含 UI 控件、相关多个小功能的合集，是一种粒度适中的模块。 并且，采用组件的话，对于代码逻辑和模块间的通信方式的改动都不大，完成老代码切换也就相对容易些。我们可以先按照物理划分，也就是将多个相同功能的类移动到同一个文件夹下，然后做成 CocoaPods 的包进行管理。 但是，仅做到这一步还不够，因为功能模块之间的耦合还是没有被解除。如果没有解除耦合关系的话，不同功能的开发还是没法独立开来，勉强开发完成后的影响范围评估也难以确定。 模块分层 底层可以是与业务无关的基础组件，比如网络和存储等； 中间层一般是通用的业务组件，比如账号、埋点、支付、购物车等； 最上层是迭代业务组件，更新频率最高。 但是并不是所有的功能都做成组件，只有那些会被多个业务或者团队使用的功能模块才需要做成组件。因为，改造成组件也是需要时间成本的，很少有公司愿意完全停下业务去进行重构，而一旦决定某业务功能模块要改成组件，就要抓住机会，严格按照 SOLID 原则去改造组件，因为返工和再优化的机会可能不会再有。 #多团队之间如何分工 在代码层面，我们通过组件化解决了大项目、多人、多团队架构的问题，但是架构问题还涉及到团队人员结构上的架构。当公司或者集团的 App 多了后，相应的团队也就多了，为了能够让产品快速迭代和稳定发展，也需要一个合理的团队结构。 首先，需要一个专门的基建团队，负责业务无关的基础功能组件和业务相关通用业务组件的开发。 然后，每个业务都由一个专门的团队来负责开发。业务可以按照功能耦合度来划分，耦合度高的业务可以划分成单独的业务团队。 基建团队人员应该是流动的，从业务团队里来，再回到业务团队中去。这么设计是因为业务团队和基建团队的边界不应该非常明显，否则就会出现基建团队埋头苦干，结果可能是做得过多、做得不够，或着功能不好用的问题，造成严重的资源浪费。 总结来讲，我想说的是团队分工要灵活，不要把人员隔离固化了，否则各干各的，做的东西相互都不用。核心上，团队分工还是要围绕着具体业务进行功能模块提炼，去解决重复建设的问题，在这个基础上把提炼出的模块做精做扎实。否则，拉一帮子人臆想出来的东西，无人问津，那就是把自己架空了。 架构设计方案协议式架构主要采用的是协议式编程的思路：在编译层面使用协议定义规范，实现可在不同地方，从而达到分布管理和维护组件的目的。这种方式也遵循了依赖反转原则，是一种很好的面向对象编程的实践。 但是，这个方案的缺点也很明显，主要体现在以下两个方面： 由于协议式编程缺少统一调度层，导致难于集中管理，特别是项目规模变大、团队变多的情况下，架构管控就会显得越来越重要。 协议式编程接口定义模式过于规范，从而使得架构的灵活性不够高。当需要引入一个新的设计模式来开发时，我们就会发现很难融入到当前架构中，缺乏架构的统一性。 虽然协议式架构有这两方面的局限性，但由于其简单易用的特点依然被很多公司采用。 中间者架构采用中间者统一管理的方式，来控制 App 的整个生命周期中组件间的调用关系。同时，iOS 对于组件接口的设计也需要保持一致性，方便中间者统一调用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto Layout自动布局]]></title>
    <url>%2F2019%2F07%2F10%2FAuto-Layout%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Auto Layout ，是苹果公司提供的一个基于约束布局，动态计算视图大小和位置的库，并且已经集成到了 Xcode 开发环境里。 在引入 Auto Layout 这种自动布局方式之前，iOS 开发都是采用手动布局的方式。而手动布局的方式，原始落后、界面开发维护效率低，对从事过前端开发的人来说更是难以适应。所以，苹果需要提供更好的界面引擎来提升开发者的体验，Auto Layout 随之出现。 Auto Layout 的来历 1997 年，Auto Layout 用到的布局算法 Cassowary 被发明了出来 2011 年，苹果公司将 Cassowary 算法运用到了自家的布局引擎 Auto Layout 中 Cassowary 能够有效解析线性等式系统和线性不等式系统，用来表示用户界面中那些相等关系和不等关系。基于此，Cassowary 开发了一种规则系统，通过约束来描述视图间的关系。约束就是规则，这个规则能够表示出一个视图相对于另一个视图的位置。 由于 Cassowary 算法让视图位置可以按照一种简单的布局思路来写，这些简单的相对位置描述可以在运行时动态地计算出视图具体的位置。视图位置的写法简化了，界面相关代码也就更易于维护。苹果公司也是看重了这一点，将其引入到了自己的系统中。 Auto Layout 的生命周期Auto Layout 不只有布局算法 Cassowary，还包含了布局在运行时的生命周期等一整套布局引擎系统，用来统一管理布局的创建、更新和销毁。了解 Auto Layout 的生命周期，是理解它的性能相关话题的基础。这样，在遇到问题，特别是性能问题时，我们才能从根儿上找到原因，从而避免或改进类似的问题。 这一整套布局引擎系统叫作 Layout Engine ，是 Auto Layout 的核心，主导着整个界面布局。 每个视图在得到自己的布局之前，Layout Engine 会将视图、约束、优先级、固定大小通过计算转换成最终的大小和位置。在 Layout Engine 里，每当约束发生变化（添加、删除视图时会触发约束变化，Activating 或 Deactivating，设置 Constant 或 Priority 时也会触发约束变化），就会触发 Deffered Layout Pass，完成后进入监听约束变化的状态。Layout Engine 在碰到约束变化后会重新计算布局，获取到布局后调用 superview.setNeedLayout()，然后进入 Deferred Layout Pass。 Deferred Layout Pass 的主要作用是做容错处理。如果有些视图在更新约束时没有确定或缺失布局声明的话，会先在这里做容错处理。 接下来，Layout Engine 会从上到下调用 layoutSubviews() ，通过 Cassowary 算法计算各个子视图的位置，算出来后将子视图的 frame 从 Layout Engine 里拷贝出来。 在这之后的处理，就和手写布局的绘制、渲染过程一样了。所以，使用 Auto Layout 和手写布局的区别，就是多了布局上的这个计算过程。 Auto Layout 性能问题Auto Layout 的性能是否有问题，我们先看看苹果公司自己是怎么说的吧。 上图是 WWDC 2018 中 202 Session 里讲到的 Auto Layout 在 iOS 12 中优化后的表现。可以看到，优化后的性能，已经基本和手写布局一样可以达到性能随着视图嵌套的数量呈线性增长了。而在此之前的 Auto Layout，视图嵌套的数量对性能的影响是呈指数级增长的。 在 1997 年时，Cassowary 是以高效的界面线性方程求解算法被提出来的。它解决的是界面的线性规划问题，而线性规划问题的解法是 Simplex 算法。单从 Simplex 算法的复杂度来看，多数情况下是没有指数时间复杂度的。而 Cassowary 算法又是在 Simplex 算法基础上对界面关系方程进行了高效的添加、修改更新操作，不会带来时间复杂度呈指数级增长的问题。 那么，如果 Cassowary 算法本身没有问题的话，问题就只可能是苹果公司在 iOS 12 之前在某些情况下没有用好这个算法。 接下来，我们再看一下 WWDC 2018 中 202 Session 的 Auto Layout 在兄弟视图独立开布局的情况。 可以看到，兄弟视图之间没有关系时，是不会出现性能呈指数增加问题的。这就表示 Cassowary 算法在添加时是高效的。但如果兄弟视图间有关系的话，在视图遍历时会不断处理和兄弟视图间的关系，这时会有修改更新计算。 由此可以看出，Auto Layout 并没有用上 Cassowary 高效修改更新的特性。 实际情况是，iOS 12 之前，很多约束变化时都会重新创建一个计算引擎 NSISEnginer 将约束关系重新加进来，然后重新计算。结果就是，涉及到的约束关系变多时，新的计算引擎需要重新计算，最终导致计算量呈指数级增加。 总体来说， iOS12 的 Auto Layout 更多地利用了 Cassowary 算法的界面更新策略，使其真正完成了高效的界面线性策略计算。 Auto Layout 的易用性很多开发者直到现在还不愿意使用 Auto Layout 的另一个原因，就是它还存在原生写法不易用的问题。 苹果公司其实也考虑到了这点。所以，苹果公司后来又提供了 VFL (Visual Format Language) 这种 DSL（Domain Specific Language，中文可翻译为“领域特定语言”） 语言来简化 Auto Layout 的写法。 本质上，Auto Layout 只是一种最基础的布局思路。在前端出现了 Flexbox 这种高级的响应式布局思路后，苹果公司也紧跟其后，基于 Auto Layout 又封装了一个类似 Flexbox 的 UIStackView，用来提高 iOS 开发响应式布局的易用性。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS申请后台活跃时间]]></title>
    <url>%2F2019%2F07%2F05%2FiOS%E7%94%B3%E8%AF%B7%E5%90%8E%E5%8F%B0%E6%B4%BB%E8%B7%83%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[由于苹果的后台机制，当我们按下home键的时候，所有线程包括主线程的任务都会被挂起，一些资源比如socket也会被系统回收，会导致很多问题，比如一个很重要的资源中断下载，或者定时器方法被暂停等等。 苹果在4.0以后提供了一种申请后台时间的机制： 1(UIBackgroundTaskIdentifier)beginBackgroundTaskWithExpirationHandler:(void (^)(void))handler 声明： 标记要开始一个新的长期运行的后台任务 参数： handler 应用程序后台剩余时间快到达为0的时候的一个处理回调，你应该使用这个回调来做一些清理工作和后台任务结束的标记，未能明确地结束任务将导致APP的终止，这个处理回调将在主线程中被同步调用。 返回值： 一个新的后台任务的唯一的标示符，你必须将这个值传给endBackgroundTask:方法来标记任务的结束。如果无法在后台运行这个方法将返回UIBackgroundTaskInvalid。 描述： 这个方法会让你的app转到后台以后继续运行一段时间，你可以在一个任务未完成将会导致影响用户体验的情况下调用此方法。例如，你可以调用次方法来获取足够的时间来传输一个很重要的文件到远程服务器或者至少尝试标记一些错误。你不应该随意的调用这个方法来保持你的app在后台长期运行。 实现比较简单，点我查看Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReactNative开发踩坑记录]]></title>
    <url>%2F2019%2F07%2F03%2FReactNative%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Could not find iPhone XXX描述： 终端运行react-native run-ios时报错，无法找到模拟器，通过xcrun simctl list devices命令查看本地模拟器列表，已经包含了运行的模拟器 原因： 不能再通过cli运行react-native run-ios 解决方案： 进入/node_modules/react-native/local-cli/runIOS/findMatchingSimulator.js文件,将 1if (!version.startsWith(&apos;iOS&apos;) &amp;&amp; !version.startsWith(&apos;tvOS&apos;)) 修改为 1if (!version.startsWith(&apos;com.apple.CoreSimulator.SimRuntime.iOS&apos;) &amp;&amp; !version.startsWith(&apos;com.apple.CoreSimulator.SimRuntime.tvOS&apos;))]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App启动速度优化与监控]]></title>
    <url>%2F2019%2F06%2F26%2FApp%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[App启动App启动类型 冷启动 冷启动是指， App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。 热启动 热启动是指 ，App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。 App启动三个阶段 main() 函数执行前； 在 main() 函数执行前，系统主要会做下面几件事情： 加载可执行文件（App 的.o 文件的集合）； 加载动态链接库，进行 rebase 指针调整和 bind 符号绑定； Objc 运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等； 初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。 在该阶段可以做一些事情来优化App的启动速度： 减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持 6 个非系统动态库合并为一个。 减少加载启动后不会去使用的类或者方法。 +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个+load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。 控制 C++ 全局变量的数量。 main() 函数执行后； main() 函数执行后的阶段，指的是从 main() 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。 首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括： 首屏初始化所需配置文件的读写操作； 首屏列表大数据的读取； 首屏渲染的大量计算等。 首屏渲染完成后。 首屏渲染后的这个阶段，主要完成的是，非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等。从函数上来看，这个阶段指的就是截止到 didFinishLaunchingWithOptions 方法作用域内执行首屏渲染之后的所有方法执行完成。简单说的话，这个阶段就是从渲染完成时开始，到 didFinishLaunchingWithOptions 方法作用域结束时结束。 这个阶段用户已经能够看到 App 的首页信息了，所以优化的优先级排在最后。但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作。 查看App启动耗时查看main()调用前花费的总时间在Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Arguments-&gt;Environment Variables-&gt;DYLD_PRINT_STATISTICS设置为YES，就可以在控制台中查看main函数执行前总共花费的多长时间。 查看加载了多少动态库在Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Diagnostics-&gt;Logging-&gt;勾选Dynamic Library Loads，就可以在控制台中查看本项目中加载的所有动态库（包括系统的和自己的）。 查看Main函数启动后的耗时main函数调用后的耗时，可以使用一些工具来监控，有一种非常笨但是很实用的方法，就是通过打点，在didFinishLaunchingWithOptions开始前打一个点，在App显示完成第一个界面再打一个点，计算两个点之间的耗时，就可以知道main函数调用后到界面显示出来的耗时了，但是这样只能笼统的知道总的耗时，并不能准确的知道时间花在了哪里。 如果想用这个打点法的话，推荐一个打点工具BLStopwatch App启动速度优化功能级别的启动优化功能级别的启动优化要从main()函数执行后这个阶段下手。思路： main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。 方法级别的启动优化优化对资源的操作将主线程上线耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载、编辑、存储图片和文件等资源。 对App启动方法耗时进行监控 定时抓取主线程上的方法调用栈，计算一段时间里各个方法耗时 定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确 而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确 这个定时时间小于所有方法的执行时间(如：0.002秒)，那么基本就能监控到所有方法，但是这样计算出来的整体耗时不够准确。一般将这个时间间隔设置成0.01秒，这样虽然很多方法耗时不准确，但是整体耗时比较准确。所以这种方式虽然单个方法耗时不是非常准确，但是相对来说，整体耗时精度够用。如，Xcode自带TimeProfiler就是采用这种方式计算的。 对 objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时。 hook 方法的意思是，在原方法开始执行时换成执行其他你指定的方法，或者在原有方法执行前后执行你指定的方法，来达到掌握和改变指定方法的目的 hook objc_msgSend 这种方式的优点是非常精确，而缺点是只能针对 Objective-C 的方法。当然，对于 c 方法和 block 也不是没有办法，你可以使用 libffi 的 ffi_call 来达成 hook，但缺点就是编写维护相关工具门槛高 综上，如果对于检查结果精准度要求高的话，我比较推荐你使用 hook objc_msgSend 方式来检查启动方法的执行耗时。 如何做一个方法级别启动耗时检查工具来辅助分析和监控？根据TimeProfiler原理，实现了一个计算主线程上所有方法耗时的工具(点我)，大致思路如下： 通过定时器，每隔0.01s，获取一次主线程的函数堆栈，将函数名称、函数地址、函数耗时模型化为TimeModel，保存在callStackDict中，其中key为函数地址，value为TimeModel 定时执行的回调中，每次都判断函数地址是否存在，如果已经存在此函数地址，就讲对应的TimeModel中的耗时增加0.01s；如果不存在此函数地址，就初始化一个TimeModel，并将时间设置为0.01s。 当主界面显示完成之后，输出此callStackDict，即可查看主线程中每个方法的耗时 欢迎各位大佬指教]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods常用操作命令]]></title>
    <url>%2F2019%2F06%2F25%2FCocoapods%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.Pod安装 创建Podfile文件 1pod init 安装podfile中的远程库 1pod install 安装podfile中的远程库，但不更新本地spec文件 2.缓存相关 查看所有spec文件的缓存，可以直接到路径下删除文件 1pod cache list 删除制定的缓存文件 1pod cache clean AFNetworking 3.踩坑记录 [!] Attempt to read non existent folder ‘/Users/xxx’ 检查一下上述报错路径中是否包含中文，如果有请更改为全英文路径再重新pod install]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceTree如何跳过注册直接使用]]></title>
    <url>%2F2019%2F06%2F25%2FSourceTree%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87%E6%B3%A8%E5%86%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Mac上SourceTree免注册使用方式​ 为什么我会总结这篇文章，想必不用多少。SourceTree的注册问题一直是个头疼的问题，一次无意中发现这么个骚操作，预计记录下来。话不多少，开始正题。 1. 下载应用​ 自行下载SourceTree应用，也可以在该链接下载。SourceTree2.7.6 密码:gjg6 2. 安装应用​ 安装下载好的程序，知道这一步 ​ ​ 然后点击取消安装，关闭SourceTree 3. 删除文件​ 划重点，关键步骤。 ​ 右键应用程序中SourceTree，显示包内容，然后在Contents文件夹中搜索Atlassian，结果如图 ​ ​ 最后一个操作，删除搜索到的所有文件，整个流程结束。 ​ 可以愉快的使用SourceTree了。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode打包异常集合]]></title>
    <url>%2F2019%2F06%2F24%2FXcode%E6%89%93%E5%8C%85%E5%BC%82%E5%B8%B8%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1. AppStore上传鉴定时报错Xcode上传AppStore验证时报错： Unable to download a software component: com.apple.transporter.mediatoolkit/1.13.0 这个错误是下载jar包失败，按照以下步骤执行，执行完之后，重新上传验证 123cd ~mv .itmstransporter/.old_itmstransporter/&quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporter&quot;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发知识体系]]></title>
    <url>%2F2019%2F06%2F23%2FiOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[graph LR iOS(iOS知识体系)-->Base(基础) iOS-->App(应用开发) iOS-->Principle(原理) iOS-->NativeAndWeb(原生与前端) %%基础 Base-->Base_Code(开发阶段) Base-->Base_Test(调试测试阶段) Base-->Base_Release(发布阶段) Base-->Base_Online(上线阶段) Base_Code-->Base_Code0(启动流程) Base_Code-->Base_Code1(界面布局) Base_Code-->Base_Code2(架构设计) Base_Test-->Base_Test0(提速调试) Base_Test-->Base_Test1(静态分析) Base_Release-->Base_Release0(自动埋点) Base_Release-->Base_Release1(体积优化) Base_Online-->Base_Online0(崩溃分析) Base_Online-->Base_Online1(卡顿监控) Base_Online-->Base_Online2(日志搜集) Base_Online-->Base_Online3(性能监控) Base_Online-->Base_Online4(多线程问题) Base_Online-->Base_Online5(电量问题) %%应用开发 App-->App0(GUI框架) App0-->App0_0(UIKit) App0-->App0_1(Core Animation) App0-->App0_2(Core Graphics) App0-->App0_3(Core Image) App0-->App0_4(OpenGL ES) App-->App1(响应式框架) App1-->App1_0(ReactCocoa) App1-->App1_1(RxSwift) App1-->App1_2(EasyReact) App-->App2(动画) App2-->App2_0(Pop) App2-->App2_1(RZTransitions) App-->App3(A/B方案) App-->App4(消息总线) App4-->App4_0(PromiseKit) App4-->App4_1(SwiftTask) App-->App5(JSON处理) App5-->App5_0(JSONModel) App5-->App5_1(Mantle) App5-->App5_2(JSONDecoder) App-->App6(布局框架) App6-->App6_0(Masonry) App6-->App6_1(SnapKit) App6-->App6_2(Cartography) App6-->App6_3(Yoga) App-->App7(富文本) App7-->App7_0(YYText) App7-->App7_1(DTCoreText) App-->App8(TDD/BDD) App-->App9(编码规范) %%原理 Principle-->Principle0(系统内核 XNU) Principle-->Principle1(AOP) Principle1-->Principle1_0(Runtime Method Swizzling) Principle1-->Principle1_1(libffi) Principle-->Principle2(内存管理) Principle-->Principle3(编译) %%原生与前端 NativeAndWeb-->NativeAndWeb0(JavaScriptCore) NativeAndWeb-->NativeAndWeb1(跨端方案) NativeAndWeb1-->NativeAndWeb1_0(React Native) NativeAndWeb1-->NativeAndWeb1_1(Weex) NativeAndWeb1-->NativeAndWeb1_2(Flutter) NativeAndWeb1-->NativeAndWeb1_3(H5) NativeAndWeb-->NativeAndWeb2(布局区别) NativeAndWeb2-->NativeAndWeb2_0(原生布局) NativeAndWeb2-->NativeAndWeb2_1(前端布局) NativeAndWeb-->NativeAndWeb3(渲染区别) NativeAndWeb3-->NativeAndWeb3_0(原生渲染) NativeAndWeb3-->NativeAndWeb3_1(React Native渲染) NativeAndWeb3-->NativeAndWeb3_2(Flutter渲染) NativeAndWeb-->NativeAndWeb4(动态化方案分析) NativeAndWeb4-->NativeAndWeb4_0(WaxPatch) NativeAndWeb4-->NativeAndWeb4_1(JSPatch) NativeAndWeb4-->NativeAndWeb4_2(OCS) NativeAndWeb4-->NativeAndWeb4_3(低风险方案)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS进入后台申请活跃时间]]></title>
    <url>%2F2019%2F06%2F22%2FiOS%E8%BF%9B%E5%85%A5%E5%90%8E%E5%8F%B0%E7%94%B3%E8%AF%B7%E6%B4%BB%E8%B7%83%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[比较简单，废话不多说，直接上代码。 BackgroundTask]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods创建podspec说明]]></title>
    <url>%2F2019%2F06%2F22%2FCocoapods%E5%88%9B%E5%BB%BApodspec%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一.创建远程私有库创建一个私有的podspec包括如下那么几个步骤: 123456- 创建并设置一个私有的Spec Repo。 - 创建Pod所需要的项目工程文件。- 向远程仓库提交工程项目。- 向私有的Spec Repo中提交podspec- 在个人项目中引入私有库。 - 更新维护podspec。 在整个过程中我们一共需要两个Git仓库。一个是用来放Pods索引的，也就是第一步中用到的，而且只有在第一次创建远程库时才需要；另一个是用来存放工程代码的远程仓库，不一定是Git仓库，其它的远程仓库也可以，本文以Git来介绍。 1. 创建并设置一个私有的Spec RepoSpec Repo是所有Pods的一个索引，相当于一个容器，所有的Pods都在这个索引里面。如 ~/CocoaPods/Specs是所有公共的Pods的索引，稍后我们创建BWTSpecs就是我们所有Pods私有库的索引。 接下来我们创建Spec Repo，在终端执行以下命令： 1pod repo add BWTSpecs http://git.bwton.com/msx-client-ios/BWTSpecs.git http://git.bwton.com/msx-client-ios/BWTSpecs.git 是我们创建好的存放BWTSpecs索引的仓库。 成功之后在~/.cocoapods/repos目录下会多出一个BWTSpecs文件。第一步完成。 PS:多人开发时，其他成员也需要执行这个命令，且其他成员需要有这个Git仓库的权限。 2. 创建Pod所需要的项目工程文件在终端进入需要创建项目的目录，然后执行： 1pod lib create BWTKit 执行完之后会有几个问题，按需要回答即可。回答完之后会自动执行pod install命令创建项目并生成依赖。 现在进入到项目目录下的Example目录下，打开workspace文件，删掉Replaceme文件，开始编辑BWTKit.podspec文件，参考以下格式： 1234567891011121314Pod::Spec.new do |s| s.name = &apos;BWTKit&apos; s.version = &apos;1.0.0&apos; s.summary = &apos;八维通基础业务模块&apos; s.description = &lt;&lt;-DESC ‘该模块主要处理码上行App中基础业务相关.’ DESC s.homepage = &apos;http://git.bwton.com&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;xujiebing&apos; =&gt; &apos;xujiebing1992@gmail.com&apos; &#125; s.source = &#123; :git =&gt; &apos;http://git.bwton.com/msx-client-ios/BWTKit.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;BWTKit/*&apos; end 添加项目需要的代码，本地先测试编译，确保编译通过。 3. 向远程仓库提交工程项目在终端中进入BWTKit目录 将本地工程文件提交到远程仓库。执行以下命令： 1234git add . git commit -m &apos;初始化项目&apos; git remote add origin http://git.bwton.com/msx-client-ios/BWTKit.git # 关联远程仓库 git push origin master # 提交到远程仓库 PS：如果push失败可以尝试命令：git push origin master -f # 覆盖远程仓库 podspec文件中需要获取Git的tag，所以我们这里需要打上tag。执行以下命令： 12git tag -m &apos;第一个tag&apos; 1.0.0 git push --tags # 推送tag到远程仓库 4. 向私有的Spec Repo中提交podspec在终端中进入BWTKit目录 先本地验证podspec文件，执行命令： 1pod lib lint 当看到以下输出表示本地验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 接下来进行远程验证，执行命令： 1pod spec lint 当看到以下输出表示远程验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 验证完之后向远程BWTSpecs提交podspec，执行命令： 1pod repo push BWTSpecs BWTKit.podspec 完成之后这个BWTKit库就添加到我们的私有BWTSpecs中了，可以进入到~/.cocoapods/repos/BWTSpecs目录下查看，也可以去远程仓库查看。 5. 在个人项目中引入私有库在需要引入私有库的项目的podfile文件中引入： 123source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; pod &apos;BWTKit&apos;, &apos;~&gt; 1.0.0&apos; PS: source ‘https://github.com/CocoaPods/Specs.git&#39; 必须要加，否则项目中引入的共有的Pods库将无法安装 6. 更新维护podspec我们已经制作好BWTKit 1.0.0版本，现在业务有变更，需要对BWTKit进行升级。 这是只需要将2，3，4，5步中的version和tag设置成新的值，然后重复2，3，4，5步即可。 二.远程私有库中引入私有库以BWTBaseBiz引入BWTKit为例 1. 创建Pod所需要的项目工程文件在终端进入需要创建项目的目录，然后执行： 1pod lib create BWTBaseBiz 执行完之后会有几个问题，按需要回答即可。回答完之后会自动执行pod install命令创建项目并生成依赖。 现在进入到项目目录下的Example目录下，打开workspace文件，删掉Replaceme文件，开始编辑BWTBaseBiz.podspec文件，参考以下格式： 123456789101112131415Pod::Spec.new do |s| s.name = &apos;BWTBaseBiz&apos; s.version = &apos;1.0.0&apos; s.summary = &apos;八维通基础业务模块&apos; s.description = &lt;&lt;-DESC ‘该模块主要处理码上行App中基础业务相关.’ DESC s.homepage = &apos;http://git.bwton.com&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;xujiebing&apos; =&gt; &apos;xujiebing1992@gmail.com&apos; &#125; s.source = &#123; :git =&gt; &apos;http://git.bwton.com/msx-client-ios/BWTBaseBiz.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;BWTBaseBiz/*&apos; s.dependency &apos;BWTKit&apos; # 注意：这一步比较关键 end 在Podfile中加入：# 注意：这一步有所区别 12source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; 进入Example目录下执行 pod install 添加项目需要的代码，本地先测试编译，确保编译通过。 2. 向远程仓库提交工程项目在终端中进入BWTBaseBiz目录 将本地工程文件提交到远程仓库。执行以下命令： 1234git add . git commit -m &apos;初始化项目&apos; git remote add origin http://git.bwton.com/msx-client-ios/BWTBaseBiz.git # 关联远程仓库 git push origin master # 提交到远程仓库 PS：如果push失败可以尝试命令：git push origin master -f # 覆盖远程仓库 podspec文件中需要获取Git的tag，所以我们这里需要打上tag。执行以下命令： 12git tag -m &apos;第一个tag&apos; 1.0.0 git push --tags # 推送tag到远程仓库 3. 向私有的Spec Repo中提交podspec在终端中进入BWTKit目录 先本地验证podspec文件，执行命令：# 注意：这一步有区别 1pod lib lint --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 当看到以下输出表示本地验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 接下来进行远程验证，执行命令：# 注意：这一步有区别 1pod spec lint --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 当看到以下输出表示远程验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 验证完之后向远程BWTSpecs提交podspec，执行命令：# 注意：这一步有区别 1pod repo push BWTSpecs BWTKit.podspec --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 完成之后这个BWTKit库就添加到我们的私有BWTSpecs中了，可以进入到~/.cocoapods/repos/BWTSpecs目录下查看，也可以去远程仓库查看。私有库引入私有库制作完毕。 4. 在个人项目中引入私有库在需要引入私有库的项目的podfile文件中引入： 123source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; pod &apos;BWTBaseBiz&apos;, &apos;~&gt; 1.0.0&apos; 这时BWTKit和BWTBaseBiz都会被引入到项目中 三.更新私有库搜索不到远程私有库时，可以执行以下操作： 1.进入终端执行命令： 1rm ~/Library/Caches/CocoaPods/search_index.json 2.进入到本地索引文件目录~/.cocoapods/repos/BWTSpecs下执行命令： 1git pull 接着搜索私有库即可搜到 四.如何删除私有库1. 删除整个BWTSpecs文件，执行命令：1pod repo remove BWTSpecs 这样本地的就删除了，还可以通过以下命令加回来： 1pod repo add BWTSpecs http://git.bwton.com/msx-client-ios/BWTSpecs.git 2. 删除某个私有库进入目录 ~/.cocoapods/repos/BWTSpecs下,删除私有库目录，执行命令： 1rm -Rf BWTKit 然后将本地的修改推到远程库，执行命令： 123git add -A git commit -m &apos;删除BWTKit私有库&apos; git push origin master 操作完毕]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS SHA1WithRSA加签验签]]></title>
    <url>%2F2019%2F06%2F22%2FiOS-SHA1WithRSA%E5%8A%A0%E7%AD%BE%E9%AA%8C%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍一点关于SHA1WithRSA的干货以及本人在开发的过程中遇到的坑 干货下载链接 关于RSA相关介绍、对称加密与非对称加密、公私钥、加密解密以及加签验签请自行百度 本人在项目中遇到的问题： 问题一：App加签之后的数据在服务端无法验签 问题描述：本人在项目中对使用的AFNetworking，并拦截了BWTAFHTTPRequestSerializer中的requestBySerializingRequest:withParameters:error:方法，将请求的包体转成json字符串进行加签，然后将加签信息作为签名放在请求头中上传到服务器，服务器验签失败 解决过程：开始怀疑是算法出了问题，网上查找资料，发现算法跟我项目中的基本是一致的，后来又是查找资料也没有解决。后来在断点调试中发现requestBySerializingRequest:withParameters:error: 中的query(AFNetworking中将包体转成json字符串，即query)变量与包体转成的json字符串不一样，于是瞬间豁然开朗，问题解决，over。 问题分析： 首先，我们先回忆一下加签验签的过程： 我们将A字符串用私钥加签，得到sign字符串；然后用公钥、A字符串和sign进行验签。说到这里大家应该明白了query变量和包体的json字符串不一样为什么会导致服务端验签不通过了。 项目中是将包体转成json字符串，使用到了MJExtension中的方法，转换出来的字符串不知道为什么多出了n和空格，这就导致我们加签的明文和服务端验签的明文(明文为query比变量)不一致(哪怕是多出一个空格也不行)，导致服务端验签失败。 问题找到了，怎么解决就不再啰嗦了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIImageView的contentModel、裁剪、layer属性以及局部拉伸详解]]></title>
    <url>%2F2019%2F06%2F22%2FUIImageView%E7%9A%84contentModel%E3%80%81%E8%A3%81%E5%89%AA%E3%80%81layer%E5%B1%9E%E6%80%A7%E4%BB%A5%E5%8F%8A%E5%B1%80%E9%83%A8%E6%8B%89%E4%BC%B8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在我们开发过程中，UIImageView是一个使用频率相对较高的控件。那么对该控件做一个全面的认识，会对我们业务开发起到十分重要的作用。这篇文章主要讲解UIImageView的contentMode属性和图片的裁剪关系，layer属性以及图片的局部拉伸。 Demo链接 contentMode该属性是UIView的属性，表示view内容的填充样式，不同属性的值的效果可参考demo 。contentModel一共有13种填充模式，分别是： UIViewContentModeScaleToFill 这是图片显示的默认模式。图片进行非等比例缩放，直到填铺满整个View区域。所以往往造成图片的变形。也就是图片的长度上缩放一定的比例填满显示区域，在宽度上缩放一定的比例填满显示区域。 UIViewContentModeScaleAspectFit 这是等比例缩放，所以使用这种缩放模式的图片永远不会变形。图片按一定比例缩放，直到在长度上或者宽度上达到View的边界就停止。没有填满区域就显示View的背景。 UIViewContentModeScaleAspectFill 这也是等比例缩放，图片也不会变形。这种缩放和上面的ScaleAspectFit正好相反，图片按一定比例缩放，直到最短的边达到View的边界。所以这种缩放一定会铺满View，超出View的图片你可以选择截掉或者不截掉。 UIViewContentModeRedraw 重绘。该模式比较特别，它不是用来说明如何展示图片的，而是告诉视图在每次设置或者更改frame的时候自动调用drawRect：方法 UIViewContentModeCenter 等比缩放，居中显示。 UIViewContentModeTop 等比缩放，顶部对齐显示。 UIViewContentModeBottom 等比缩放，底部对齐显示。 UIViewContentModeLeft 等比缩放，左侧对齐显示。 UIViewContentModeRight 等比缩放，右侧对齐显示。 UIViewContentModeTopLeft 等比缩放，左上角对齐显示。 UIViewContentModeTopRight 等比缩放，右上角对齐显示。 UIViewContentModeBottomLeft 等比缩放，左下角对齐显示。 UIViewContentModeBottomRight 等比缩放，右下角对齐显示。 contentModel与图片裁剪通过demo效果，我们发现contentModel也可以实现裁剪功能。那么普通的裁剪方法跟contentModel属性有什么区别，我们可以通过demo来观察。 layer属性的简单介绍 layer是UIView的一个属性，属于CALayer。CALayer可以在以后专门做一个专题来分享，这里只是对layer做个简单的介绍。 可以通过设置UIView的CALayer实现阴影、边框、圆角和透明等效果 CALayer没有处理事件响应的接口 UIView主要实现UI视觉上的管理，CALayer主要实现UI内容的绘制 图片的局部拉伸根据不同的业务需求，contentModel以及图片裁剪已经不能满足业务需求，这时候局部拉伸就能发挥作用了。 -(UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets; 该方法是图片的局部拉伸方法。UIEdgesets是设置图片拉伸区域距离图片的顶部、左部、下部、有部的距离。例如，一个50*50像素的图片，UIEdgeInsets全部设置为5，表示对图片中间40 * 40的区域进行拉伸。效果参考demo。 Android的ImageView的相关属性scaleType属性，控制图片缩放或移动 属性值说明 center无缩放，按原图大小显示图片，当图片宽高大于View的宽高时，截取图片中间部分显示 centerCrop按比例拉伸原图直至于填充满View宽高，并显示在View的中间。 centerInside当View的宽高&gt;=图片的宽高时，图片居中显示原大小反之将原图按比例缩放至View的宽高居中显示。 fitCenter按比例拉伸原图直至等于View某边的宽高，且显示在View的中间 fitStart按比例拉伸图片，且显示在View的左上边 fitEnd按比例拉伸图片，且显示在View的右下边 fitXY拉伸图片（不按比例）以填充View的宽高 matrix用矩阵来绘图 tint属性，为图片设置渲染颜色，单独设置时，会覆盖掉原有背景图片]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode导出ipa文件时四种类型说明]]></title>
    <url>%2F2019%2F06%2F21%2FXcode%E5%AF%BC%E5%87%BAipa%E6%96%87%E4%BB%B6%E6%97%B6%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[在 iOS 导出 ipa包的时候 会有四个选项： Save for iOS App Store Deployment 保存到本地 准备上传App Store 或者在越狱的iOS设备上使用 Save for Ad Hoc Deployment 保存到本地 准备在账号添加的可使用设备上使用（具体为在开发者账户下添加可用设备的udid），该app包是发布证书编译的（The app will be code signed with the distribution certificate.） Save for Enterprise Deployment 这种主要针对企业级账户下 准备本地服务器分发的app Save for Development Deployment 针对内部测试使用，主要给开发者的设备(具体也为在开发者账户下添加可用设备的udid)。该app包是开发证书编译的（The app will be code signed with your development certificate）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安全性与隐私设置]]></title>
    <url>%2F2019%2F06%2F21%2FMac%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E9%9A%90%E7%A7%81%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Mac中安装非AppStore下载的应用时经常会软件已损坏，无法安装的情况。这是需要在安全性与隐私中设置允许任何来源 打开终端 执行命令 1sudo spctl --master-disable 打开安全设置选项，就会发现「任何来源」选项回来了 PS:其实对于升级系统前，已经是任何来源选项的，还会显示，不会改变，但别的选项的，升级后就会消失.]]></content>
      <categories>
        <category>Mac相关</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不花钱的百度网盘SVIP]]></title>
    <url>%2F2019%2F06%2F21%2F%E4%B8%8D%E8%8A%B1%E9%92%B1%E7%9A%84%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98SVIP%2F</url>
    <content type="text"><![CDATA[百度网盘非SVIP下载网速受限，上传文件大小受限怎么办？ 充会员，那是不可能的，哈哈！ 敲黑板，划重点 macOS上先安装好百度网盘 登录账号 执行脚本 1cd ~/Downloads &amp;&amp; git clone https://github.com/CodeTips/BaiduNetdiskPlugin-macOS.git &amp;&amp; ./BaiduNetdiskPlugin-macOS/Other/[Install.sh] 打开百度网盘，开始享受SVIP吧]]></content>
      <categories>
        <category>Mac相关</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
</search>
