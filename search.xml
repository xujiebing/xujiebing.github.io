<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[App如何实现极速编译调试]]></title>
    <url>%2F2019%2F07%2F18%2FApp%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[虽然动态链接器的实际应用能够帮助我们缩短App编译时间，但是每次修改代码之后还是需要重新启动App，再走一遍调试流程。对于我们开发人员来说，提高编译调试的速度就是提高生产力。那么，目前有哪些工具是可以实现动态调试的呢？ Swift PlaygroundPlayground是 Xcode 里集成的一个能够快速、实时调试程序的工具，可以实现所见即所得的效果，如下图所示： Flutter Hot ReloadFlutter 是 Google 开发的一个跨平台开发框架，调试也是快速实时的。官方的效果动画如下： Injection for XcodeInjection 的工具可以动态地将 Swift 或 Objective-C 的代码在已运行的程序中执行，以加快调试速度，同时保证程序不用重启。John Holdsworth 也提供了动画演示效果，如下：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链接器：符号是怎么绑定到地址上的]]></title>
    <url>%2F2019%2F07%2F16%2F%E9%93%BE%E6%8E%A5%E5%99%A8%EF%BC%9A%E7%AC%A6%E5%8F%B7%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%91%E5%AE%9A%E5%88%B0%E5%9C%B0%E5%9D%80%E4%B8%8A%E7%9A%84%2F</url>
    <content type="text"><![CDATA[链接器最主要的作用，就是将符号绑定到地址上 iOS 开发为什么使用的是编译器？iOS 编写的代码是先使用编译器把代码编译成机器码，然后直接在 CPU 上执行机器码的。之所以不使用解释器来运行代码，是因为苹果公司希望 iPhone 的执行效率更高、运行速度能达到最快。 为什么说用解释器运行代码的速度不够快呢？ 因为解释器会在运行时解释执行代码，获取一段代码后就会将其翻译成目标代码（就是字节码（Bytecode）），然后一句一句地执行目标代码。 也就是说，解释器，是在运行时才去解析代码，这样就比在运行之前通过编译器生成一份完整的机器码再去执行的效率要低。 优点 缺点 编译器 1.效率高2.运行速度快 1.调试周期长 解释器 1.调试方便2.缩短开发周期和功能更新周期 1.执行效率低 iOS 开发使用的到底是什么编译器现在苹果公司使用的编译器是 LLVM，相比于 Xcode 5 版本前使用的 GCC，编译速度提高了 3 倍。同时，苹果公司也反过来主导了 LLVM 的发展，让 LLVM 可以针对苹果公司的硬件进行更多的优化。 LLVM 是编译器工具链技术的一个集合。而其中的 lld 项目，就是内置链接器。编译器会对每个文件进行编译，生成 Mach-O（可执行文件）；链接器会将项目中的多个 Mach-O 文件合并成一个。 编译的几个主要过程： 首先，你写好代码后，LLVM 会预处理你的代码，比如把宏嵌入到对应的位置。 预处理完后，LLVM 会对代码进行词法分析和语法分析，生成 AST 。 AST 是抽象语法树，结构上比代码更精简，遍历起来更快，所以使用 AST 能够更快速地进行静态检查，同时还能更快地生成 IR（中间表示）。 最后 AST 会生成 IR，IR 是一种更接近机器码的语言，区别在于和平台无关，通过 IR 可以生成多份适合不同平台的机器码。对于 iOS 系统，IR 生成的可执行文件就是 Mach-O。 编译时链接器做了什么Mach-O 文件里面的内容，主要就是代码和数据：代码是函数的定义；数据是全局变量的定义，包括全局变量的初始值。不管是代码还是数据，它们的实例都需要由符号将其关联起来。 为什么呢？因为 Mach-O 文件里的那些代码，比如 if、for、while 生成的机器指令序列，要操作的数据会存储在某个地方，变量符号就需要绑定到数据的存储地址。你写的代码还会引用其他的代码，引用的函数符号也需要绑定到该函数的地址上。 而链接器的作用，就是完成变量、函数符号和其地址绑定这样的任务。而这里我们所说的符号，就可以理解为变量名和函数名。 项目中Mach-O文件的合并链接器为什么还要把项目中的多个 Mach-O 文件合并成一个？ 你肯定不希望一个项目是在一个文件里从头写到尾的吧。项目中文件之间的变量和接口函数都是相互依赖的，所以这时我们就需要通过链接器将项目中生成的多个 Mach-O 文件的符号和地址绑定起来。 没有这个绑定过程的话，单个文件生成的 Mach-O 文件是无法正常运行起来的。因为，如果运行时碰到调用在其他文件中实现的函数的情况时，就会找不到这个调用函数的地址，从而无法继续执行。 链接器在链接多个目标文件的过程中，会创建一个符号表，用于记录所有已定义的和所有未定义的符号。链接时如果出现相同符号的情况，就会出现“ld: dumplicate symbols”的错误信息；如果在其他目标文件里没有找到符号，就会提示“Undefined symbols”的错误信息。 链接器对代码主要做了哪几件事儿 去项目文件里查找目标代码文件里没有定义的变量。 扫描项目中的不同文件，将所有符号定义和引用地址收集起来，并放到全局符号表中。 计算合并后长度及位置，生成同类型的段进行合并，建立绑定。 对项目中不同文件里的变量进行地址重定位。 动态库链接 静态库 静态库是编译时链接的库，需要链接进你的 Mach-O 文件里，如果需要更新就要重新编译一次，无法动态加载和更新 动态库 动态库是运行时链接的库，使用 dyld 就可以实现动态加载 Mach-O 文件是编译后的产物，而动态库在运行时才会被链接，并没参与 Mach-O 文件的编译和链接，所以 Mach-O 文件中并没有包含动态库里的符号定义。也就是说，这些符号会显示为“未定义”，但它们的名字和对应的库的路径会被记录下来。运行时通过 dlopen 和 dlsym 导入动态库时，先根据记录的库路径找到对应的库，再通过记录的名字符号找到绑定的地址。 dlopen 会把共享库载入运行进程的地址空间，载入的共享库也会有未定义的符号，这样会触发更多的共享库被载入。dlopen 也可以选择是立刻解析所有引用还是滞后去做。dlopen 打开动态库后返回的是引用的指针，dlsym 的作用就是通过 dlopen 返回的动态库指针和函数符号，得到函数的地址然后使用。 使用 dyld 加载动态库，有两种方式：有程序启动加载时绑定和符号第一次被用到时绑定。为了减少启动时间，大部分动态库使用的都是符号第一次被用到时再绑定的方式。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计合理的架构]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%AE%BE%E8%AE%A1%E5%90%88%E7%90%86%E7%9A%84%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[简单架构向大型项目架构演进中，解决三个问题，即：模块粒度应该如何划分？如何分层？多团队如何协作？而在这其中，模块粒度的划分是架构设计中非常关键的一步。同时，这也是一个细活，我们最好可以在不同阶段采用不同的粒度划分模块。 模块粒度应该怎么划分模块划分为什么要遵循原则项目规模变大后，模块划分必须遵循一定的原则。如果模块划分规则不规范、不清晰，就会导致代码耦合严重的问题，并加大架构重构的难度。这些问题主要表现在： 业务需求不断，业务开发不能停。重新划分模块的工作量越大，成本越高，重构技改需求排上日程的难度也就越大。 老业务代码年久失修，没有注释，修改起来需要重新梳理逻辑和关系，耗时长。 模块划分原则对于 iOS 这种面向对象编程的开发模式来说，我们应该遵循以下五个原则，即 SOLID 原则。 单一功能原则：对象功能要单一，不要在一个对象里添加很多功能。 开闭原则：扩展是开放的，修改是封闭的。 里氏替换原则：子类对象是可以替代基类对象的。 接口隔离原则：接口的用途要单一，不要在一个接口上根据不同入参实现多个功能。 依赖反转原则：方法应该依赖抽象，不要依赖实例。iOS 开发就是高层业务方法依赖于协议。 同时，遵守这五个原则是开发出容易维护和扩展的架构的基础。 选择合适的模块粒度iOS 开发中的组件，不是 UI 的控件，也不是 ViewController 这种大 UI 和功能的集合。因为，UI 控件的粒度太小，而页面的粒度又太大。iOS 组件，应该是包含 UI 控件、相关多个小功能的合集，是一种粒度适中的模块。 并且，采用组件的话，对于代码逻辑和模块间的通信方式的改动都不大，完成老代码切换也就相对容易些。我们可以先按照物理划分，也就是将多个相同功能的类移动到同一个文件夹下，然后做成 CocoaPods 的包进行管理。 但是，仅做到这一步还不够，因为功能模块之间的耦合还是没有被解除。如果没有解除耦合关系的话，不同功能的开发还是没法独立开来，勉强开发完成后的影响范围评估也难以确定。 模块分层 底层可以是与业务无关的基础组件，比如网络和存储等； 中间层一般是通用的业务组件，比如账号、埋点、支付、购物车等； 最上层是迭代业务组件，更新频率最高。 但是并不是所有的功能都做成组件，只有那些会被多个业务或者团队使用的功能模块才需要做成组件。因为，改造成组件也是需要时间成本的，很少有公司愿意完全停下业务去进行重构，而一旦决定某业务功能模块要改成组件，就要抓住机会，严格按照 SOLID 原则去改造组件，因为返工和再优化的机会可能不会再有。 #多团队之间如何分工 在代码层面，我们通过组件化解决了大项目、多人、多团队架构的问题，但是架构问题还涉及到团队人员结构上的架构。当公司或者集团的 App 多了后，相应的团队也就多了，为了能够让产品快速迭代和稳定发展，也需要一个合理的团队结构。 首先，需要一个专门的基建团队，负责业务无关的基础功能组件和业务相关通用业务组件的开发。 然后，每个业务都由一个专门的团队来负责开发。业务可以按照功能耦合度来划分，耦合度高的业务可以划分成单独的业务团队。 基建团队人员应该是流动的，从业务团队里来，再回到业务团队中去。这么设计是因为业务团队和基建团队的边界不应该非常明显，否则就会出现基建团队埋头苦干，结果可能是做得过多、做得不够，或着功能不好用的问题，造成严重的资源浪费。 总结来讲，我想说的是团队分工要灵活，不要把人员隔离固化了，否则各干各的，做的东西相互都不用。核心上，团队分工还是要围绕着具体业务进行功能模块提炼，去解决重复建设的问题，在这个基础上把提炼出的模块做精做扎实。否则，拉一帮子人臆想出来的东西，无人问津，那就是把自己架空了。 架构设计方案协议式架构主要采用的是协议式编程的思路：在编译层面使用协议定义规范，实现可在不同地方，从而达到分布管理和维护组件的目的。这种方式也遵循了依赖反转原则，是一种很好的面向对象编程的实践。 但是，这个方案的缺点也很明显，主要体现在以下两个方面： 由于协议式编程缺少统一调度层，导致难于集中管理，特别是项目规模变大、团队变多的情况下，架构管控就会显得越来越重要。 协议式编程接口定义模式过于规范，从而使得架构的灵活性不够高。当需要引入一个新的设计模式来开发时，我们就会发现很难融入到当前架构中，缺乏架构的统一性。 虽然协议式架构有这两方面的局限性，但由于其简单易用的特点依然被很多公司采用。 中间者架构采用中间者统一管理的方式，来控制 App 的整个生命周期中组件间的调用关系。同时，iOS 对于组件接口的设计也需要保持一致性，方便中间者统一调用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto Layout自动布局]]></title>
    <url>%2F2019%2F07%2F10%2FAuto-Layout%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Auto Layout ，是苹果公司提供的一个基于约束布局，动态计算视图大小和位置的库，并且已经集成到了 Xcode 开发环境里。 在引入 Auto Layout 这种自动布局方式之前，iOS 开发都是采用手动布局的方式。而手动布局的方式，原始落后、界面开发维护效率低，对从事过前端开发的人来说更是难以适应。所以，苹果需要提供更好的界面引擎来提升开发者的体验，Auto Layout 随之出现。 Auto Layout 的来历 1997 年，Auto Layout 用到的布局算法 Cassowary 被发明了出来 2011 年，苹果公司将 Cassowary 算法运用到了自家的布局引擎 Auto Layout 中 Cassowary 能够有效解析线性等式系统和线性不等式系统，用来表示用户界面中那些相等关系和不等关系。基于此，Cassowary 开发了一种规则系统，通过约束来描述视图间的关系。约束就是规则，这个规则能够表示出一个视图相对于另一个视图的位置。 由于 Cassowary 算法让视图位置可以按照一种简单的布局思路来写，这些简单的相对位置描述可以在运行时动态地计算出视图具体的位置。视图位置的写法简化了，界面相关代码也就更易于维护。苹果公司也是看重了这一点，将其引入到了自己的系统中。 Auto Layout 的生命周期Auto Layout 不只有布局算法 Cassowary，还包含了布局在运行时的生命周期等一整套布局引擎系统，用来统一管理布局的创建、更新和销毁。了解 Auto Layout 的生命周期，是理解它的性能相关话题的基础。这样，在遇到问题，特别是性能问题时，我们才能从根儿上找到原因，从而避免或改进类似的问题。 这一整套布局引擎系统叫作 Layout Engine ，是 Auto Layout 的核心，主导着整个界面布局。 每个视图在得到自己的布局之前，Layout Engine 会将视图、约束、优先级、固定大小通过计算转换成最终的大小和位置。在 Layout Engine 里，每当约束发生变化（添加、删除视图时会触发约束变化，Activating 或 Deactivating，设置 Constant 或 Priority 时也会触发约束变化），就会触发 Deffered Layout Pass，完成后进入监听约束变化的状态。Layout Engine 在碰到约束变化后会重新计算布局，获取到布局后调用 superview.setNeedLayout()，然后进入 Deferred Layout Pass。 Deferred Layout Pass 的主要作用是做容错处理。如果有些视图在更新约束时没有确定或缺失布局声明的话，会先在这里做容错处理。 接下来，Layout Engine 会从上到下调用 layoutSubviews() ，通过 Cassowary 算法计算各个子视图的位置，算出来后将子视图的 frame 从 Layout Engine 里拷贝出来。 在这之后的处理，就和手写布局的绘制、渲染过程一样了。所以，使用 Auto Layout 和手写布局的区别，就是多了布局上的这个计算过程。 Auto Layout 性能问题Auto Layout 的性能是否有问题，我们先看看苹果公司自己是怎么说的吧。 上图是 WWDC 2018 中 202 Session 里讲到的 Auto Layout 在 iOS 12 中优化后的表现。可以看到，优化后的性能，已经基本和手写布局一样可以达到性能随着视图嵌套的数量呈线性增长了。而在此之前的 Auto Layout，视图嵌套的数量对性能的影响是呈指数级增长的。 在 1997 年时，Cassowary 是以高效的界面线性方程求解算法被提出来的。它解决的是界面的线性规划问题，而线性规划问题的解法是 Simplex 算法。单从 Simplex 算法的复杂度来看，多数情况下是没有指数时间复杂度的。而 Cassowary 算法又是在 Simplex 算法基础上对界面关系方程进行了高效的添加、修改更新操作，不会带来时间复杂度呈指数级增长的问题。 那么，如果 Cassowary 算法本身没有问题的话，问题就只可能是苹果公司在 iOS 12 之前在某些情况下没有用好这个算法。 接下来，我们再看一下 WWDC 2018 中 202 Session 的 Auto Layout 在兄弟视图独立开布局的情况。 可以看到，兄弟视图之间没有关系时，是不会出现性能呈指数增加问题的。这就表示 Cassowary 算法在添加时是高效的。但如果兄弟视图间有关系的话，在视图遍历时会不断处理和兄弟视图间的关系，这时会有修改更新计算。 由此可以看出，Auto Layout 并没有用上 Cassowary 高效修改更新的特性。 实际情况是，iOS 12 之前，很多约束变化时都会重新创建一个计算引擎 NSISEnginer 将约束关系重新加进来，然后重新计算。结果就是，涉及到的约束关系变多时，新的计算引擎需要重新计算，最终导致计算量呈指数级增加。 总体来说， iOS12 的 Auto Layout 更多地利用了 Cassowary 算法的界面更新策略，使其真正完成了高效的界面线性策略计算。 Auto Layout 的易用性很多开发者直到现在还不愿意使用 Auto Layout 的另一个原因，就是它还存在原生写法不易用的问题。 苹果公司其实也考虑到了这点。所以，苹果公司后来又提供了 VFL (Visual Format Language) 这种 DSL（Domain Specific Language，中文可翻译为“领域特定语言”） 语言来简化 Auto Layout 的写法。 本质上，Auto Layout 只是一种最基础的布局思路。在前端出现了 Flexbox 这种高级的响应式布局思路后，苹果公司也紧跟其后，基于 Auto Layout 又封装了一个类似 Flexbox 的 UIStackView，用来提高 iOS 开发响应式布局的易用性。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS申请后台活跃时间]]></title>
    <url>%2F2019%2F07%2F05%2FiOS%E7%94%B3%E8%AF%B7%E5%90%8E%E5%8F%B0%E6%B4%BB%E8%B7%83%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[由于苹果的后台机制，当我们按下home键的时候，所有线程包括主线程的任务都会被挂起，一些资源比如socket也会被系统回收，会导致很多问题，比如一个很重要的资源中断下载，或者定时器方法被暂停等等。 苹果在4.0以后提供了一种申请后台时间的机制： 1(UIBackgroundTaskIdentifier)beginBackgroundTaskWithExpirationHandler:(void (^)(void))handler 声明： 标记要开始一个新的长期运行的后台任务 参数： handler 应用程序后台剩余时间快到达为0的时候的一个处理回调，你应该使用这个回调来做一些清理工作和后台任务结束的标记，未能明确地结束任务将导致APP的终止，这个处理回调将在主线程中被同步调用。 返回值： 一个新的后台任务的唯一的标示符，你必须将这个值传给endBackgroundTask:方法来标记任务的结束。如果无法在后台运行这个方法将返回UIBackgroundTaskInvalid。 描述： 这个方法会让你的app转到后台以后继续运行一段时间，你可以在一个任务未完成将会导致影响用户体验的情况下调用此方法。例如，你可以调用次方法来获取足够的时间来传输一个很重要的文件到远程服务器或者至少尝试标记一些错误。你不应该随意的调用这个方法来保持你的app在后台长期运行。 实现比较简单，点我查看Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReactNative开发踩坑记录]]></title>
    <url>%2F2019%2F07%2F03%2FReactNative%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Could not find iPhone XXX描述： 终端运行react-native run-ios时报错，无法找到模拟器，通过xcrun simctl list devices命令查看本地模拟器列表，已经包含了运行的模拟器 原因： 不能再通过cli运行react-native run-ios 解决方案： 进入/node_modules/react-native/local-cli/runIOS/findMatchingSimulator.js文件,将 1if (!version.startsWith(&apos;iOS&apos;) &amp;&amp; !version.startsWith(&apos;tvOS&apos;)) 修改为 1if (!version.startsWith(&apos;com.apple.CoreSimulator.SimRuntime.iOS&apos;) &amp;&amp; !version.startsWith(&apos;com.apple.CoreSimulator.SimRuntime.tvOS&apos;))]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App启动速度优化与监控]]></title>
    <url>%2F2019%2F06%2F26%2FApp%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[App启动App启动类型 冷启动 冷启动是指， App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。 热启动 热启动是指 ，App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。 App启动三个阶段 main() 函数执行前； 在 main() 函数执行前，系统主要会做下面几件事情： 加载可执行文件（App 的.o 文件的集合）； 加载动态链接库，进行 rebase 指针调整和 bind 符号绑定； Objc 运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等； 初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。 在该阶段可以做一些事情来优化App的启动速度： 减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持 6 个非系统动态库合并为一个。 减少加载启动后不会去使用的类或者方法。 +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个+load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。 控制 C++ 全局变量的数量。 main() 函数执行后； main() 函数执行后的阶段，指的是从 main() 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。 首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括： 首屏初始化所需配置文件的读写操作； 首屏列表大数据的读取； 首屏渲染的大量计算等。 首屏渲染完成后。 首屏渲染后的这个阶段，主要完成的是，非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等。从函数上来看，这个阶段指的就是截止到 didFinishLaunchingWithOptions 方法作用域内执行首屏渲染之后的所有方法执行完成。简单说的话，这个阶段就是从渲染完成时开始，到 didFinishLaunchingWithOptions 方法作用域结束时结束。 这个阶段用户已经能够看到 App 的首页信息了，所以优化的优先级排在最后。但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作。 查看App启动耗时查看main()调用前花费的总时间在Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Arguments-&gt;Environment Variables-&gt;DYLD_PRINT_STATISTICS设置为YES，就可以在控制台中查看main函数执行前总共花费的多长时间。 查看加载了多少动态库在Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Diagnostics-&gt;Logging-&gt;勾选Dynamic Library Loads，就可以在控制台中查看本项目中加载的所有动态库（包括系统的和自己的）。 查看Main函数启动后的耗时main函数调用后的耗时，可以使用一些工具来监控，有一种非常笨但是很实用的方法，就是通过打点，在didFinishLaunchingWithOptions开始前打一个点，在App显示完成第一个界面再打一个点，计算两个点之间的耗时，就可以知道main函数调用后到界面显示出来的耗时了，但是这样只能笼统的知道总的耗时，并不能准确的知道时间花在了哪里。 如果想用这个打点法的话，推荐一个打点工具BLStopwatch App启动速度优化功能级别的启动优化功能级别的启动优化要从main()函数执行后这个阶段下手。思路： main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。 方法级别的启动优化优化对资源的操作将主线程上线耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载、编辑、存储图片和文件等资源。 对App启动方法耗时进行监控 定时抓取主线程上的方法调用栈，计算一段时间里各个方法耗时 定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确 而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确 这个定时时间小于所有方法的执行时间(如：0.002秒)，那么基本就能监控到所有方法，但是这样计算出来的整体耗时不够准确。一般将这个时间间隔设置成0.01秒，这样虽然很多方法耗时不准确，但是整体耗时比较准确。所以这种方式虽然单个方法耗时不是非常准确，但是相对来说，整体耗时精度够用。如，Xcode自带TimeProfiler就是采用这种方式计算的。 对 objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时。 hook 方法的意思是，在原方法开始执行时换成执行其他你指定的方法，或者在原有方法执行前后执行你指定的方法，来达到掌握和改变指定方法的目的 hook objc_msgSend 这种方式的优点是非常精确，而缺点是只能针对 Objective-C 的方法。当然，对于 c 方法和 block 也不是没有办法，你可以使用 libffi 的 ffi_call 来达成 hook，但缺点就是编写维护相关工具门槛高 综上，如果对于检查结果精准度要求高的话，我比较推荐你使用 hook objc_msgSend 方式来检查启动方法的执行耗时。 如何做一个方法级别启动耗时检查工具来辅助分析和监控？根据TimeProfiler原理，实现了一个计算主线程上所有方法耗时的工具(点我)，大致思路如下： 通过定时器，每隔0.01s，获取一次主线程的函数堆栈，将函数名称、函数地址、函数耗时模型化为TimeModel，保存在callStackDict中，其中key为函数地址，value为TimeModel 定时执行的回调中，每次都判断函数地址是否存在，如果已经存在此函数地址，就讲对应的TimeModel中的耗时增加0.01s；如果不存在此函数地址，就初始化一个TimeModel，并将时间设置为0.01s。 当主界面显示完成之后，输出此callStackDict，即可查看主线程中每个方法的耗时 欢迎各位大佬指教]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods常用操作命令]]></title>
    <url>%2F2019%2F06%2F25%2FCocoapods%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.Pod安装 创建Podfile文件 1pod init 安装podfile中的远程库 1pod install 安装podfile中的远程库，但不更新本地spec文件 2.缓存相关 查看所有spec文件的缓存，可以直接到路径下删除文件 1pod cache list 删除制定的缓存文件 1pod cache clean AFNetworking 3.踩坑记录 [!] Attempt to read non existent folder ‘/Users/xxx’ 检查一下上述报错路径中是否包含中文，如果有请更改为全英文路径再重新pod install]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceTree如何跳过注册直接使用]]></title>
    <url>%2F2019%2F06%2F25%2FSourceTree%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87%E6%B3%A8%E5%86%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Mac上SourceTree免注册使用方式​ 为什么我会总结这篇文章，想必不用多少。SourceTree的注册问题一直是个头疼的问题，一次无意中发现这么个骚操作，预计记录下来。话不多少，开始正题。 1. 下载应用​ 自行下载SourceTree应用，也可以在该链接下载。SourceTree2.7.6 密码:gjg6 2. 安装应用​ 安装下载好的程序，知道这一步 ​ ​ 然后点击取消安装，关闭SourceTree 3. 删除文件​ 划重点，关键步骤。 ​ 右键应用程序中SourceTree，显示包内容，然后在Contents文件夹中搜索Atlassian，结果如图 ​ ​ 最后一个操作，删除搜索到的所有文件，整个流程结束。 ​ 可以愉快的使用SourceTree了。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode打包异常集合]]></title>
    <url>%2F2019%2F06%2F24%2FXcode%E6%89%93%E5%8C%85%E5%BC%82%E5%B8%B8%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1. AppStore上传鉴定时报错Xcode上传AppStore验证时报错： Unable to download a software component: com.apple.transporter.mediatoolkit/1.13.0 这个错误是下载jar包失败，按照以下步骤执行，执行完之后，重新上传验证 123cd ~mv .itmstransporter/.old_itmstransporter/&quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporter&quot;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发知识体系]]></title>
    <url>%2F2019%2F06%2F23%2FiOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[graph LR iOS(iOS知识体系)-->Base(基础) iOS-->App(应用开发) iOS-->Principle(原理) iOS-->NativeAndWeb(原生与前端) %%基础 Base-->Base_Code(开发阶段) Base-->Base_Test(调试测试阶段) Base-->Base_Release(发布阶段) Base-->Base_Online(上线阶段) Base_Code-->Base_Code0(启动流程) Base_Code-->Base_Code1(界面布局) Base_Code-->Base_Code2(架构设计) Base_Test-->Base_Test0(提速调试) Base_Test-->Base_Test1(静态分析) Base_Release-->Base_Release0(自动埋点) Base_Release-->Base_Release1(体积优化) Base_Online-->Base_Online0(崩溃分析) Base_Online-->Base_Online1(卡顿监控) Base_Online-->Base_Online2(日志搜集) Base_Online-->Base_Online3(性能监控) Base_Online-->Base_Online4(多线程问题) Base_Online-->Base_Online5(电量问题) %%应用开发 App-->App0(GUI框架) App0-->App0_0(UIKit) App0-->App0_1(Core Animation) App0-->App0_2(Core Graphics) App0-->App0_3(Core Image) App0-->App0_4(OpenGL ES) App-->App1(响应式框架) App1-->App1_0(ReactCocoa) App1-->App1_1(RxSwift) App1-->App1_2(EasyReact) App-->App2(动画) App2-->App2_0(Pop) App2-->App2_1(RZTransitions) App-->App3(A/B方案) App-->App4(消息总线) App4-->App4_0(PromiseKit) App4-->App4_1(SwiftTask) App-->App5(JSON处理) App5-->App5_0(JSONModel) App5-->App5_1(Mantle) App5-->App5_2(JSONDecoder) App-->App6(布局框架) App6-->App6_0(Masonry) App6-->App6_1(SnapKit) App6-->App6_2(Cartography) App6-->App6_3(Yoga) App-->App7(富文本) App7-->App7_0(YYText) App7-->App7_1(DTCoreText) App-->App8(TDD/BDD) App-->App9(编码规范) %%原理 Principle-->Principle0(系统内核 XNU) Principle-->Principle1(AOP) Principle1-->Principle1_0(Runtime Method Swizzling) Principle1-->Principle1_1(libffi) Principle-->Principle2(内存管理) Principle-->Principle3(编译) %%原生与前端 NativeAndWeb-->NativeAndWeb0(JavaScriptCore) NativeAndWeb-->NativeAndWeb1(跨端方案) NativeAndWeb1-->NativeAndWeb1_0(React Native) NativeAndWeb1-->NativeAndWeb1_1(Weex) NativeAndWeb1-->NativeAndWeb1_2(Flutter) NativeAndWeb1-->NativeAndWeb1_3(H5) NativeAndWeb-->NativeAndWeb2(布局区别) NativeAndWeb2-->NativeAndWeb2_0(原生布局) NativeAndWeb2-->NativeAndWeb2_1(前端布局) NativeAndWeb-->NativeAndWeb3(渲染区别) NativeAndWeb3-->NativeAndWeb3_0(原生渲染) NativeAndWeb3-->NativeAndWeb3_1(React Native渲染) NativeAndWeb3-->NativeAndWeb3_2(Flutter渲染) NativeAndWeb-->NativeAndWeb4(动态化方案分析) NativeAndWeb4-->NativeAndWeb4_0(WaxPatch) NativeAndWeb4-->NativeAndWeb4_1(JSPatch) NativeAndWeb4-->NativeAndWeb4_2(OCS) NativeAndWeb4-->NativeAndWeb4_3(低风险方案)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记-iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS进入后台申请活跃时间]]></title>
    <url>%2F2019%2F06%2F22%2FiOS%E8%BF%9B%E5%85%A5%E5%90%8E%E5%8F%B0%E7%94%B3%E8%AF%B7%E6%B4%BB%E8%B7%83%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[比较简单，废话不多说，直接上代码。 BackgroundTask]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods创建podspec说明]]></title>
    <url>%2F2019%2F06%2F22%2FCocoapods%E5%88%9B%E5%BB%BApodspec%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一.创建远程私有库创建一个私有的podspec包括如下那么几个步骤: 123456- 创建并设置一个私有的Spec Repo。 - 创建Pod所需要的项目工程文件。- 向远程仓库提交工程项目。- 向私有的Spec Repo中提交podspec- 在个人项目中引入私有库。 - 更新维护podspec。 在整个过程中我们一共需要两个Git仓库。一个是用来放Pods索引的，也就是第一步中用到的，而且只有在第一次创建远程库时才需要；另一个是用来存放工程代码的远程仓库，不一定是Git仓库，其它的远程仓库也可以，本文以Git来介绍。 1. 创建并设置一个私有的Spec RepoSpec Repo是所有Pods的一个索引，相当于一个容器，所有的Pods都在这个索引里面。如 ~/CocoaPods/Specs是所有公共的Pods的索引，稍后我们创建BWTSpecs就是我们所有Pods私有库的索引。 接下来我们创建Spec Repo，在终端执行以下命令： 1pod repo add BWTSpecs http://git.bwton.com/msx-client-ios/BWTSpecs.git http://git.bwton.com/msx-client-ios/BWTSpecs.git 是我们创建好的存放BWTSpecs索引的仓库。 成功之后在~/.cocoapods/repos目录下会多出一个BWTSpecs文件。第一步完成。 PS:多人开发时，其他成员也需要执行这个命令，且其他成员需要有这个Git仓库的权限。 2. 创建Pod所需要的项目工程文件在终端进入需要创建项目的目录，然后执行： 1pod lib create BWTKit 执行完之后会有几个问题，按需要回答即可。回答完之后会自动执行pod install命令创建项目并生成依赖。 现在进入到项目目录下的Example目录下，打开workspace文件，删掉Replaceme文件，开始编辑BWTKit.podspec文件，参考以下格式： 1234567891011121314Pod::Spec.new do |s| s.name = &apos;BWTKit&apos; s.version = &apos;1.0.0&apos; s.summary = &apos;八维通基础业务模块&apos; s.description = &lt;&lt;-DESC ‘该模块主要处理码上行App中基础业务相关.’ DESC s.homepage = &apos;http://git.bwton.com&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;xujiebing&apos; =&gt; &apos;xujiebing1992@gmail.com&apos; &#125; s.source = &#123; :git =&gt; &apos;http://git.bwton.com/msx-client-ios/BWTKit.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;BWTKit/*&apos; end 添加项目需要的代码，本地先测试编译，确保编译通过。 3. 向远程仓库提交工程项目在终端中进入BWTKit目录 将本地工程文件提交到远程仓库。执行以下命令： 1234git add . git commit -m &apos;初始化项目&apos; git remote add origin http://git.bwton.com/msx-client-ios/BWTKit.git # 关联远程仓库 git push origin master # 提交到远程仓库 PS：如果push失败可以尝试命令：git push origin master -f # 覆盖远程仓库 podspec文件中需要获取Git的tag，所以我们这里需要打上tag。执行以下命令： 12git tag -m &apos;第一个tag&apos; 1.0.0 git push --tags # 推送tag到远程仓库 4. 向私有的Spec Repo中提交podspec在终端中进入BWTKit目录 先本地验证podspec文件，执行命令： 1pod lib lint 当看到以下输出表示本地验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 接下来进行远程验证，执行命令： 1pod spec lint 当看到以下输出表示远程验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 验证完之后向远程BWTSpecs提交podspec，执行命令： 1pod repo push BWTSpecs BWTKit.podspec 完成之后这个BWTKit库就添加到我们的私有BWTSpecs中了，可以进入到~/.cocoapods/repos/BWTSpecs目录下查看，也可以去远程仓库查看。 5. 在个人项目中引入私有库在需要引入私有库的项目的podfile文件中引入： 123source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; pod &apos;BWTKit&apos;, &apos;~&gt; 1.0.0&apos; PS: source ‘https://github.com/CocoaPods/Specs.git&#39; 必须要加，否则项目中引入的共有的Pods库将无法安装 6. 更新维护podspec我们已经制作好BWTKit 1.0.0版本，现在业务有变更，需要对BWTKit进行升级。 这是只需要将2，3，4，5步中的version和tag设置成新的值，然后重复2，3，4，5步即可。 二.远程私有库中引入私有库以BWTBaseBiz引入BWTKit为例 1. 创建Pod所需要的项目工程文件在终端进入需要创建项目的目录，然后执行： 1pod lib create BWTBaseBiz 执行完之后会有几个问题，按需要回答即可。回答完之后会自动执行pod install命令创建项目并生成依赖。 现在进入到项目目录下的Example目录下，打开workspace文件，删掉Replaceme文件，开始编辑BWTBaseBiz.podspec文件，参考以下格式： 123456789101112131415Pod::Spec.new do |s| s.name = &apos;BWTBaseBiz&apos; s.version = &apos;1.0.0&apos; s.summary = &apos;八维通基础业务模块&apos; s.description = &lt;&lt;-DESC ‘该模块主要处理码上行App中基础业务相关.’ DESC s.homepage = &apos;http://git.bwton.com&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;xujiebing&apos; =&gt; &apos;xujiebing1992@gmail.com&apos; &#125; s.source = &#123; :git =&gt; &apos;http://git.bwton.com/msx-client-ios/BWTBaseBiz.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;BWTBaseBiz/*&apos; s.dependency &apos;BWTKit&apos; # 注意：这一步比较关键 end 在Podfile中加入：# 注意：这一步有所区别 12source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; 进入Example目录下执行 pod install 添加项目需要的代码，本地先测试编译，确保编译通过。 2. 向远程仓库提交工程项目在终端中进入BWTBaseBiz目录 将本地工程文件提交到远程仓库。执行以下命令： 1234git add . git commit -m &apos;初始化项目&apos; git remote add origin http://git.bwton.com/msx-client-ios/BWTBaseBiz.git # 关联远程仓库 git push origin master # 提交到远程仓库 PS：如果push失败可以尝试命令：git push origin master -f # 覆盖远程仓库 podspec文件中需要获取Git的tag，所以我们这里需要打上tag。执行以下命令： 12git tag -m &apos;第一个tag&apos; 1.0.0 git push --tags # 推送tag到远程仓库 3. 向私有的Spec Repo中提交podspec在终端中进入BWTKit目录 先本地验证podspec文件，执行命令：# 注意：这一步有区别 1pod lib lint --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 当看到以下输出表示本地验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 接下来进行远程验证，执行命令：# 注意：这一步有区别 1pod spec lint --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 当看到以下输出表示远程验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 验证完之后向远程BWTSpecs提交podspec，执行命令：# 注意：这一步有区别 1pod repo push BWTSpecs BWTKit.podspec --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 完成之后这个BWTKit库就添加到我们的私有BWTSpecs中了，可以进入到~/.cocoapods/repos/BWTSpecs目录下查看，也可以去远程仓库查看。私有库引入私有库制作完毕。 4. 在个人项目中引入私有库在需要引入私有库的项目的podfile文件中引入： 123source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; pod &apos;BWTBaseBiz&apos;, &apos;~&gt; 1.0.0&apos; 这时BWTKit和BWTBaseBiz都会被引入到项目中 三.更新私有库搜索不到远程私有库时，可以执行以下操作： 1.进入终端执行命令： 1rm ~/Library/Caches/CocoaPods/search_index.json 2.进入到本地索引文件目录~/.cocoapods/repos/BWTSpecs下执行命令： 1git pull 接着搜索私有库即可搜到 四.如何删除私有库1. 删除整个BWTSpecs文件，执行命令：1pod repo remove BWTSpecs 这样本地的就删除了，还可以通过以下命令加回来： 1pod repo add BWTSpecs http://git.bwton.com/msx-client-ios/BWTSpecs.git 2. 删除某个私有库进入目录 ~/.cocoapods/repos/BWTSpecs下,删除私有库目录，执行命令： 1rm -Rf BWTKit 然后将本地的修改推到远程库，执行命令： 123git add -A git commit -m &apos;删除BWTKit私有库&apos; git push origin master 操作完毕]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS SHA1WithRSA加签验签]]></title>
    <url>%2F2019%2F06%2F22%2FiOS-SHA1WithRSA%E5%8A%A0%E7%AD%BE%E9%AA%8C%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍一点关于SHA1WithRSA的干货以及本人在开发的过程中遇到的坑 干货下载链接 关于RSA相关介绍、对称加密与非对称加密、公私钥、加密解密以及加签验签请自行百度 本人在项目中遇到的问题： 问题一：App加签之后的数据在服务端无法验签 问题描述：本人在项目中对使用的AFNetworking，并拦截了BWTAFHTTPRequestSerializer中的requestBySerializingRequest:withParameters:error:方法，将请求的包体转成json字符串进行加签，然后将加签信息作为签名放在请求头中上传到服务器，服务器验签失败 解决过程：开始怀疑是算法出了问题，网上查找资料，发现算法跟我项目中的基本是一致的，后来又是查找资料也没有解决。后来在断点调试中发现requestBySerializingRequest:withParameters:error: 中的query(AFNetworking中将包体转成json字符串，即query)变量与包体转成的json字符串不一样，于是瞬间豁然开朗，问题解决，over。 问题分析： 首先，我们先回忆一下加签验签的过程： 我们将A字符串用私钥加签，得到sign字符串；然后用公钥、A字符串和sign进行验签。说到这里大家应该明白了query变量和包体的json字符串不一样为什么会导致服务端验签不通过了。 项目中是将包体转成json字符串，使用到了MJExtension中的方法，转换出来的字符串不知道为什么多出了n和空格，这就导致我们加签的明文和服务端验签的明文(明文为query比变量)不一致(哪怕是多出一个空格也不行)，导致服务端验签失败。 问题找到了，怎么解决就不再啰嗦了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIImageView的contentModel、裁剪、layer属性以及局部拉伸详解]]></title>
    <url>%2F2019%2F06%2F22%2FUIImageView%E7%9A%84contentModel%E3%80%81%E8%A3%81%E5%89%AA%E3%80%81layer%E5%B1%9E%E6%80%A7%E4%BB%A5%E5%8F%8A%E5%B1%80%E9%83%A8%E6%8B%89%E4%BC%B8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在我们开发过程中，UIImageView是一个使用频率相对较高的控件。那么对该控件做一个全面的认识，会对我们业务开发起到十分重要的作用。这篇文章主要讲解UIImageView的contentMode属性和图片的裁剪关系，layer属性以及图片的局部拉伸。 Demo链接 contentMode该属性是UIView的属性，表示view内容的填充样式，不同属性的值的效果可参考demo 。contentModel一共有13种填充模式，分别是： UIViewContentModeScaleToFill 这是图片显示的默认模式。图片进行非等比例缩放，直到填铺满整个View区域。所以往往造成图片的变形。也就是图片的长度上缩放一定的比例填满显示区域，在宽度上缩放一定的比例填满显示区域。 UIViewContentModeScaleAspectFit 这是等比例缩放，所以使用这种缩放模式的图片永远不会变形。图片按一定比例缩放，直到在长度上或者宽度上达到View的边界就停止。没有填满区域就显示View的背景。 UIViewContentModeScaleAspectFill 这也是等比例缩放，图片也不会变形。这种缩放和上面的ScaleAspectFit正好相反，图片按一定比例缩放，直到最短的边达到View的边界。所以这种缩放一定会铺满View，超出View的图片你可以选择截掉或者不截掉。 UIViewContentModeRedraw 重绘。该模式比较特别，它不是用来说明如何展示图片的，而是告诉视图在每次设置或者更改frame的时候自动调用drawRect：方法 UIViewContentModeCenter 等比缩放，居中显示。 UIViewContentModeTop 等比缩放，顶部对齐显示。 UIViewContentModeBottom 等比缩放，底部对齐显示。 UIViewContentModeLeft 等比缩放，左侧对齐显示。 UIViewContentModeRight 等比缩放，右侧对齐显示。 UIViewContentModeTopLeft 等比缩放，左上角对齐显示。 UIViewContentModeTopRight 等比缩放，右上角对齐显示。 UIViewContentModeBottomLeft 等比缩放，左下角对齐显示。 UIViewContentModeBottomRight 等比缩放，右下角对齐显示。 contentModel与图片裁剪通过demo效果，我们发现contentModel也可以实现裁剪功能。那么普通的裁剪方法跟contentModel属性有什么区别，我们可以通过demo来观察。 layer属性的简单介绍 layer是UIView的一个属性，属于CALayer。CALayer可以在以后专门做一个专题来分享，这里只是对layer做个简单的介绍。 可以通过设置UIView的CALayer实现阴影、边框、圆角和透明等效果 CALayer没有处理事件响应的接口 UIView主要实现UI视觉上的管理，CALayer主要实现UI内容的绘制 图片的局部拉伸根据不同的业务需求，contentModel以及图片裁剪已经不能满足业务需求，这时候局部拉伸就能发挥作用了。 -(UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets; 该方法是图片的局部拉伸方法。UIEdgesets是设置图片拉伸区域距离图片的顶部、左部、下部、有部的距离。例如，一个50*50像素的图片，UIEdgeInsets全部设置为5，表示对图片中间40 * 40的区域进行拉伸。效果参考demo。 Android的ImageView的相关属性scaleType属性，控制图片缩放或移动 属性值说明 center无缩放，按原图大小显示图片，当图片宽高大于View的宽高时，截取图片中间部分显示 centerCrop按比例拉伸原图直至于填充满View宽高，并显示在View的中间。 centerInside当View的宽高&gt;=图片的宽高时，图片居中显示原大小反之将原图按比例缩放至View的宽高居中显示。 fitCenter按比例拉伸原图直至等于View某边的宽高，且显示在View的中间 fitStart按比例拉伸图片，且显示在View的左上边 fitEnd按比例拉伸图片，且显示在View的右下边 fitXY拉伸图片（不按比例）以填充View的宽高 matrix用矩阵来绘图 tint属性，为图片设置渲染颜色，单独设置时，会覆盖掉原有背景图片]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode导出ipa文件时四种类型说明]]></title>
    <url>%2F2019%2F06%2F21%2FXcode%E5%AF%BC%E5%87%BAipa%E6%96%87%E4%BB%B6%E6%97%B6%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[在 iOS 导出 ipa包的时候 会有四个选项： Save for iOS App Store Deployment 保存到本地 准备上传App Store 或者在越狱的iOS设备上使用 Save for Ad Hoc Deployment 保存到本地 准备在账号添加的可使用设备上使用（具体为在开发者账户下添加可用设备的udid），该app包是发布证书编译的（The app will be code signed with the distribution certificate.） Save for Enterprise Deployment 这种主要针对企业级账户下 准备本地服务器分发的app Save for Development Deployment 针对内部测试使用，主要给开发者的设备(具体也为在开发者账户下添加可用设备的udid)。该app包是开发证书编译的（The app will be code signed with your development certificate）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安全性与隐私设置]]></title>
    <url>%2F2019%2F06%2F21%2FMac%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E9%9A%90%E7%A7%81%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Mac中安装非AppStore下载的应用时经常会软件已损坏，无法安装的情况。这是需要在安全性与隐私中设置允许任何来源 打开终端 执行命令 1sudo spctl --master-disable 打开安全设置选项，就会发现「任何来源」选项回来了 PS:其实对于升级系统前，已经是任何来源选项的，还会显示，不会改变，但别的选项的，升级后就会消失.]]></content>
      <categories>
        <category>Mac相关</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不花钱的百度网盘SVIP]]></title>
    <url>%2F2019%2F06%2F21%2F%E4%B8%8D%E8%8A%B1%E9%92%B1%E7%9A%84%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98SVIP%2F</url>
    <content type="text"><![CDATA[百度网盘非SVIP下载网速受限，上传文件大小受限怎么办？ 充会员，那是不可能的，哈哈！ 敲黑板，划重点 macOS上先安装好百度网盘 登录账号 执行脚本 1cd ~/Downloads &amp;&amp; git clone https://github.com/CodeTips/BaiduNetdiskPlugin-macOS.git &amp;&amp; ./BaiduNetdiskPlugin-macOS/Other/[Install.sh] 打开百度网盘，开始享受SVIP吧]]></content>
      <categories>
        <category>Mac相关</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
</search>
