<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[App启动速度优化与监控(二)]]></title>
    <url>%2F2019%2F06%2F26%2FApp%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%91%E6%8E%A7(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[一. App启动1. App启动类型 冷启动 冷启动是指， App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。 热启动 热启动是指 ，App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。 2. App启动三个阶段 main() 函数执行前； 在 main() 函数执行前，系统主要会做下面几件事情： 加载可执行文件（App 的.o 文件的集合）； 加载动态链接库，进行 rebase 指针调整和 bind 符号绑定； Objc 运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等； 初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。 在该阶段可以做一些事情来优化App的启动速度： 减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持 6 个非系统动态库合并为一个。 减少加载启动后不会去使用的类或者方法。 +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个+load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。 控制 C++ 全局变量的数量。 main() 函数执行后； 首屏渲染完成后。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods常用操作命令]]></title>
    <url>%2F2019%2F06%2F25%2FCocoapods%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.Pod安装 创建Podfile文件 1pod init 安装podfile中的远程库 1pod install 安装podfile中的远程库，但不更新本地spec文件 2.缓存相关 查看所有spec文件的缓存，可以直接到路径下删除文件 1pod cache list 删除制定的缓存文件 1pod cache clean AFNetworking]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceTree如何跳过注册直接使用]]></title>
    <url>%2F2019%2F06%2F25%2FSourceTree%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87%E6%B3%A8%E5%86%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Mac上SourceTree免注册使用方式​ 为什么我会总结这篇文章，想必不用多少。SourceTree的注册问题一直是个头疼的问题，一次无意中发现这么个骚操作，预计记录下来。话不多少，开始正题。 1. 下载应用​ 自行下载SourceTree应用，也可以在该链接下载。SourceTree2.7.6 密码:gjg6 2. 安装应用​ 安装下载好的程序，知道这一步 ​ ​ 然后点击取消安装，关闭SourceTree 3. 删除文件​ 划重点，关键步骤。 ​ 右键应用程序中SourceTree，显示包内容，然后在Contents文件夹中搜索Atlassian，结果如图 ​ ​ 最后一个操作，删除搜索到的所有文件，整个流程结束。 ​ 可以愉快的使用SourceTree了。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode打包异常集合]]></title>
    <url>%2F2019%2F06%2F24%2FXcode%E6%89%93%E5%8C%85%E5%BC%82%E5%B8%B8%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1. AppStore上传鉴定时报错Xcode上传AppStore验证时报错： Unable to download a software component: com.apple.transporter.mediatoolkit/1.13.0 这个错误是下载jar包失败，按照以下步骤执行，执行完之后，重新上传验证 123cd ~mv .itmstransporter/.old_itmstransporter/&quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporter&quot;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发知识体系(一)]]></title>
    <url>%2F2019%2F06%2F23%2FiOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[graph LR iOS(iOS知识体系)-->Base(基础) iOS-->App(应用开发) iOS-->Principle(原理) iOS-->NativeAndWeb(原生与前端) %%基础 Base-->Base_Code(开发阶段) Base-->Base_Test(调试测试阶段) Base-->Base_Release(发布阶段) Base-->Base_Online(上线阶段) Base_Code-->Base_Code0(启动流程) Base_Code-->Base_Code1(界面布局) Base_Code-->Base_Code2(架构设计) Base_Test-->Base_Test0(提速调试) Base_Test-->Base_Test1(静态分析) Base_Release-->Base_Release0(自动埋点) Base_Release-->Base_Release1(体积优化) Base_Online-->Base_Online0(崩溃分析) Base_Online-->Base_Online1(卡顿监控) Base_Online-->Base_Online2(日志搜集) Base_Online-->Base_Online3(性能监控) Base_Online-->Base_Online4(多线程问题) Base_Online-->Base_Online5(电量问题) %%应用开发 App-->App0(GUI框架) App0-->App0_0(UIKit) App0-->App0_1(Core Animation) App0-->App0_2(Core Graphics) App0-->App0_3(Core Image) App0-->App0_4(OpenGL ES) App-->App1(响应式框架) App1-->App1_0(ReactCocoa) App1-->App1_1(RxSwift) App1-->App1_2(EasyReact) App-->App2(动画) App2-->App2_0(Pop) App2-->App2_1(RZTransitions) App-->App3(A/B方案) App-->App4(消息总线) App4-->App4_0(PromiseKit) App4-->App4_1(SwiftTask) App-->App5(JSON处理) App5-->App5_0(JSONModel) App5-->App5_1(Mantle) App5-->App5_2(JSONDecoder) App-->App6(布局框架) App6-->App6_0(Masonry) App6-->App6_1(SnapKit) App6-->App6_2(Cartography) App6-->App6_3(Yoga) App-->App7(富文本) App7-->App7_0(YYText) App7-->App7_1(DTCoreText) App-->App8(TDD/BDD) App-->App9(编码规范) %%原理 Principle-->Principle0(系统内核 XNU) Principle-->Principle1(AOP) Principle1-->Principle1_0(Runtime Method Swizzling) Principle1-->Principle1_1(libffi) Principle-->Principle2(内存管理) Principle-->Principle3(编译) %%原生与前端 NativeAndWeb-->NativeAndWeb0(JavaScriptCore) NativeAndWeb-->NativeAndWeb1(跨端方案) NativeAndWeb1-->NativeAndWeb1_0(React Native) NativeAndWeb1-->NativeAndWeb1_1(Weex) NativeAndWeb1-->NativeAndWeb1_2(Flutter) NativeAndWeb1-->NativeAndWeb1_3(H5) NativeAndWeb-->NativeAndWeb2(布局区别) NativeAndWeb2-->NativeAndWeb2_0(原生布局) NativeAndWeb2-->NativeAndWeb2_1(前端布局) NativeAndWeb-->NativeAndWeb3(渲染区别) NativeAndWeb3-->NativeAndWeb3_0(原生渲染) NativeAndWeb3-->NativeAndWeb3_1(React Native渲染) NativeAndWeb3-->NativeAndWeb3_2(Flutter渲染) NativeAndWeb-->NativeAndWeb4(动态化方案分析) NativeAndWeb4-->NativeAndWeb4_0(WaxPatch) NativeAndWeb4-->NativeAndWeb4_1(JSPatch) NativeAndWeb4-->NativeAndWeb4_2(OCS) NativeAndWeb4-->NativeAndWeb4_3(低风险方案)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS进入后台申请活跃时间]]></title>
    <url>%2F2019%2F06%2F22%2FiOS%E8%BF%9B%E5%85%A5%E5%90%8E%E5%8F%B0%E7%94%B3%E8%AF%B7%E6%B4%BB%E8%B7%83%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[比较简单，废话不多说，直接上代码。 BackgroundTask]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods创建podspec说明]]></title>
    <url>%2F2019%2F06%2F22%2FCocoapods%E5%88%9B%E5%BB%BApodspec%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一.创建远程私有库创建一个私有的podspec包括如下那么几个步骤: 123456- 创建并设置一个私有的Spec Repo。 - 创建Pod所需要的项目工程文件。- 向远程仓库提交工程项目。- 向私有的Spec Repo中提交podspec- 在个人项目中引入私有库。 - 更新维护podspec。 在整个过程中我们一共需要两个Git仓库。一个是用来放Pods索引的，也就是第一步中用到的，而且只有在第一次创建远程库时才需要；另一个是用来存放工程代码的远程仓库，不一定是Git仓库，其它的远程仓库也可以，本文以Git来介绍。 1. 创建并设置一个私有的Spec RepoSpec Repo是所有Pods的一个索引，相当于一个容器，所有的Pods都在这个索引里面。如 ~/CocoaPods/Specs是所有公共的Pods的索引，稍后我们创建BWTSpecs就是我们所有Pods私有库的索引。 接下来我们创建Spec Repo，在终端执行以下命令： 1pod repo add BWTSpecs http://git.bwton.com/msx-client-ios/BWTSpecs.git http://git.bwton.com/msx-client-ios/BWTSpecs.git 是我们创建好的存放BWTSpecs索引的仓库。 成功之后在~/.cocoapods/repos目录下会多出一个BWTSpecs文件。第一步完成。 PS:多人开发时，其他成员也需要执行这个命令，且其他成员需要有这个Git仓库的权限。 2. 创建Pod所需要的项目工程文件在终端进入需要创建项目的目录，然后执行： 1pod lib create BWTKit 执行完之后会有几个问题，按需要回答即可。回答完之后会自动执行pod install命令创建项目并生成依赖。 现在进入到项目目录下的Example目录下，打开workspace文件，删掉Replaceme文件，开始编辑BWTKit.podspec文件，参考以下格式： 1234567891011121314Pod::Spec.new do |s| s.name = &apos;BWTKit&apos; s.version = &apos;1.0.0&apos; s.summary = &apos;八维通基础业务模块&apos; s.description = &lt;&lt;-DESC ‘该模块主要处理码上行App中基础业务相关.’ DESC s.homepage = &apos;http://git.bwton.com&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;xujiebing&apos; =&gt; &apos;xujiebing1992@gmail.com&apos; &#125; s.source = &#123; :git =&gt; &apos;http://git.bwton.com/msx-client-ios/BWTKit.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;BWTKit/*&apos; end 添加项目需要的代码，本地先测试编译，确保编译通过。 3. 向远程仓库提交工程项目在终端中进入BWTKit目录 将本地工程文件提交到远程仓库。执行以下命令： 1234git add . git commit -m &apos;初始化项目&apos; git remote add origin http://git.bwton.com/msx-client-ios/BWTKit.git # 关联远程仓库 git push origin master # 提交到远程仓库 PS：如果push失败可以尝试命令：git push origin master -f # 覆盖远程仓库 podspec文件中需要获取Git的tag，所以我们这里需要打上tag。执行以下命令： 12git tag -m &apos;第一个tag&apos; 1.0.0 git push --tags # 推送tag到远程仓库 4. 向私有的Spec Repo中提交podspec在终端中进入BWTKit目录 先本地验证podspec文件，执行命令： 1pod lib lint 当看到以下输出表示本地验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 接下来进行远程验证，执行命令： 1pod spec lint 当看到以下输出表示远程验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 验证完之后向远程BWTSpecs提交podspec，执行命令： 1pod repo push BWTSpecs BWTKit.podspec 完成之后这个BWTKit库就添加到我们的私有BWTSpecs中了，可以进入到~/.cocoapods/repos/BWTSpecs目录下查看，也可以去远程仓库查看。 5. 在个人项目中引入私有库在需要引入私有库的项目的podfile文件中引入： 123source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; pod &apos;BWTKit&apos;, &apos;~&gt; 1.0.0&apos; PS: source ‘https://github.com/CocoaPods/Specs.git&#39; 必须要加，否则项目中引入的共有的Pods库将无法安装 6. 更新维护podspec我们已经制作好BWTKit 1.0.0版本，现在业务有变更，需要对BWTKit进行升级。 这是只需要将2，3，4，5步中的version和tag设置成新的值，然后重复2，3，4，5步即可。 二.远程私有库中引入私有库以BWTBaseBiz引入BWTKit为例 1. 创建Pod所需要的项目工程文件在终端进入需要创建项目的目录，然后执行： 1pod lib create BWTBaseBiz 执行完之后会有几个问题，按需要回答即可。回答完之后会自动执行pod install命令创建项目并生成依赖。 现在进入到项目目录下的Example目录下，打开workspace文件，删掉Replaceme文件，开始编辑BWTBaseBiz.podspec文件，参考以下格式： 123456789101112131415Pod::Spec.new do |s| s.name = &apos;BWTBaseBiz&apos; s.version = &apos;1.0.0&apos; s.summary = &apos;八维通基础业务模块&apos; s.description = &lt;&lt;-DESC ‘该模块主要处理码上行App中基础业务相关.’ DESC s.homepage = &apos;http://git.bwton.com&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;xujiebing&apos; =&gt; &apos;xujiebing1992@gmail.com&apos; &#125; s.source = &#123; :git =&gt; &apos;http://git.bwton.com/msx-client-ios/BWTBaseBiz.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;BWTBaseBiz/*&apos; s.dependency &apos;BWTKit&apos; # 注意：这一步比较关键 end 在Podfile中加入：# 注意：这一步有所区别 12source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; 进入Example目录下执行 pod install 添加项目需要的代码，本地先测试编译，确保编译通过。 2. 向远程仓库提交工程项目在终端中进入BWTBaseBiz目录 将本地工程文件提交到远程仓库。执行以下命令： 1234git add . git commit -m &apos;初始化项目&apos; git remote add origin http://git.bwton.com/msx-client-ios/BWTBaseBiz.git # 关联远程仓库 git push origin master # 提交到远程仓库 PS：如果push失败可以尝试命令：git push origin master -f # 覆盖远程仓库 podspec文件中需要获取Git的tag，所以我们这里需要打上tag。执行以下命令： 12git tag -m &apos;第一个tag&apos; 1.0.0 git push --tags # 推送tag到远程仓库 3. 向私有的Spec Repo中提交podspec在终端中进入BWTKit目录 先本地验证podspec文件，执行命令：# 注意：这一步有区别 1pod lib lint --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 当看到以下输出表示本地验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 接下来进行远程验证，执行命令：# 注意：这一步有区别 1pod spec lint --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 当看到以下输出表示远程验证通过 12-&gt; BWTKit (1.0.0) BWTKit passed validation. 验证完之后向远程BWTSpecs提交podspec，执行命令：# 注意：这一步有区别 1pod repo push BWTSpecs BWTKit.podspec --sources=http://git.bwton.com/msx-client-ios/BWTSpecs.git,https://github.com/CocoaPods/Specs.git 完成之后这个BWTKit库就添加到我们的私有BWTSpecs中了，可以进入到~/.cocoapods/repos/BWTSpecs目录下查看，也可以去远程仓库查看。私有库引入私有库制作完毕。 4. 在个人项目中引入私有库在需要引入私有库的项目的podfile文件中引入： 123source &apos;https://github.com/CocoaPods/Specs.git&apos; source &apos;http://git.bwton.com/msx-client-ios/BWTSpecs.git&apos; pod &apos;BWTBaseBiz&apos;, &apos;~&gt; 1.0.0&apos; 这时BWTKit和BWTBaseBiz都会被引入到项目中 三.更新私有库搜索不到远程私有库时，可以执行以下操作： 1.进入终端执行命令： 1rm ~/Library/Caches/CocoaPods/search_index.json 2.进入到本地索引文件目录~/.cocoapods/repos/BWTSpecs下执行命令： 1git pull 接着搜索私有库即可搜到 四.如何删除私有库1. 删除整个BWTSpecs文件，执行命令：1pod repo remove BWTSpecs 这样本地的就删除了，还可以通过以下命令加回来： 1pod repo add BWTSpecs http://git.bwton.com/msx-client-ios/BWTSpecs.git 2. 删除某个私有库进入目录 ~/.cocoapods/repos/BWTSpecs下,删除私有库目录，执行命令： 1rm -Rf BWTKit 然后将本地的修改推到远程库，执行命令： 123git add -A git commit -m &apos;删除BWTKit私有库&apos; git push origin master 操作完毕]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS SHA1WithRSA加签验签]]></title>
    <url>%2F2019%2F06%2F22%2FiOS-SHA1WithRSA%E5%8A%A0%E7%AD%BE%E9%AA%8C%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍一点关于SHA1WithRSA的干货以及本人在开发的过程中遇到的坑 干货下载链接 关于RSA相关介绍、对称加密与非对称加密、公私钥、加密解密以及加签验签请自行百度 本人在项目中遇到的问题： 问题一：App加签之后的数据在服务端无法验签 问题描述：本人在项目中对使用的AFNetworking，并拦截了BWTAFHTTPRequestSerializer中的requestBySerializingRequest:withParameters:error:方法，将请求的包体转成json字符串进行加签，然后将加签信息作为签名放在请求头中上传到服务器，服务器验签失败 解决过程：开始怀疑是算法出了问题，网上查找资料，发现算法跟我项目中的基本是一致的，后来又是查找资料也没有解决。后来在断点调试中发现requestBySerializingRequest:withParameters:error: 中的query(AFNetworking中将包体转成json字符串，即query)变量与包体转成的json字符串不一样，于是瞬间豁然开朗，问题解决，over。 问题分析： 首先，我们先回忆一下加签验签的过程： 我们将A字符串用私钥加签，得到sign字符串；然后用公钥、A字符串和sign进行验签。说到这里大家应该明白了query变量和包体的json字符串不一样为什么会导致服务端验签不通过了。 项目中是将包体转成json字符串，使用到了MJExtension中的方法，转换出来的字符串不知道为什么多出了n和空格，这就导致我们加签的明文和服务端验签的明文(明文为query比变量)不一致(哪怕是多出一个空格也不行)，导致服务端验签失败。 问题找到了，怎么解决就不再啰嗦了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIImageView的contentModel、裁剪、layer属性以及局部拉伸详解]]></title>
    <url>%2F2019%2F06%2F22%2FUIImageView%E7%9A%84contentModel%E3%80%81%E8%A3%81%E5%89%AA%E3%80%81layer%E5%B1%9E%E6%80%A7%E4%BB%A5%E5%8F%8A%E5%B1%80%E9%83%A8%E6%8B%89%E4%BC%B8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在我们开发过程中，UIImageView是一个使用频率相对较高的控件。那么对该控件做一个全面的认识，会对我们业务开发起到十分重要的作用。这篇文章主要讲解UIImageView的contentMode属性和图片的裁剪关系，layer属性以及图片的局部拉伸。 Demo链接 contentMode该属性是UIView的属性，表示view内容的填充样式，不同属性的值的效果可参考demo 。contentModel一共有13种填充模式，分别是： UIViewContentModeScaleToFill 这是图片显示的默认模式。图片进行非等比例缩放，直到填铺满整个View区域。所以往往造成图片的变形。也就是图片的长度上缩放一定的比例填满显示区域，在宽度上缩放一定的比例填满显示区域。 UIViewContentModeScaleAspectFit 这是等比例缩放，所以使用这种缩放模式的图片永远不会变形。图片按一定比例缩放，直到在长度上或者宽度上达到View的边界就停止。没有填满区域就显示View的背景。 UIViewContentModeScaleAspectFill 这也是等比例缩放，图片也不会变形。这种缩放和上面的ScaleAspectFit正好相反，图片按一定比例缩放，直到最短的边达到View的边界。所以这种缩放一定会铺满View，超出View的图片你可以选择截掉或者不截掉。 UIViewContentModeRedraw 重绘。该模式比较特别，它不是用来说明如何展示图片的，而是告诉视图在每次设置或者更改frame的时候自动调用drawRect：方法 UIViewContentModeCenter 等比缩放，居中显示。 UIViewContentModeTop 等比缩放，顶部对齐显示。 UIViewContentModeBottom 等比缩放，底部对齐显示。 UIViewContentModeLeft 等比缩放，左侧对齐显示。 UIViewContentModeRight 等比缩放，右侧对齐显示。 UIViewContentModeTopLeft 等比缩放，左上角对齐显示。 UIViewContentModeTopRight 等比缩放，右上角对齐显示。 UIViewContentModeBottomLeft 等比缩放，左下角对齐显示。 UIViewContentModeBottomRight 等比缩放，右下角对齐显示。 contentModel与图片裁剪通过demo效果，我们发现contentModel也可以实现裁剪功能。那么普通的裁剪方法跟contentModel属性有什么区别，我们可以通过demo来观察。 layer属性的简单介绍 layer是UIView的一个属性，属于CALayer。CALayer可以在以后专门做一个专题来分享，这里只是对layer做个简单的介绍。 可以通过设置UIView的CALayer实现阴影、边框、圆角和透明等效果 CALayer没有处理事件响应的接口 UIView主要实现UI视觉上的管理，CALayer主要实现UI内容的绘制 图片的局部拉伸根据不同的业务需求，contentModel以及图片裁剪已经不能满足业务需求，这时候局部拉伸就能发挥作用了。 -(UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets; 该方法是图片的局部拉伸方法。UIEdgesets是设置图片拉伸区域距离图片的顶部、左部、下部、有部的距离。例如，一个50*50像素的图片，UIEdgeInsets全部设置为5，表示对图片中间40 * 40的区域进行拉伸。效果参考demo。 Android的ImageView的相关属性scaleType属性，控制图片缩放或移动 属性值说明 center无缩放，按原图大小显示图片，当图片宽高大于View的宽高时，截取图片中间部分显示 centerCrop按比例拉伸原图直至于填充满View宽高，并显示在View的中间。 centerInside当View的宽高&gt;=图片的宽高时，图片居中显示原大小反之将原图按比例缩放至View的宽高居中显示。 fitCenter按比例拉伸原图直至等于View某边的宽高，且显示在View的中间 fitStart按比例拉伸图片，且显示在View的左上边 fitEnd按比例拉伸图片，且显示在View的右下边 fitXY拉伸图片（不按比例）以填充View的宽高 matrix用矩阵来绘图 tint属性，为图片设置渲染颜色，单独设置时，会覆盖掉原有背景图片]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode导出ipa文件时四种类型说明]]></title>
    <url>%2F2019%2F06%2F21%2FXcode%E5%AF%BC%E5%87%BAipa%E6%96%87%E4%BB%B6%E6%97%B6%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[在 iOS 导出 ipa包的时候 会有四个选项： Save for iOS App Store Deployment 保存到本地 准备上传App Store 或者在越狱的iOS设备上使用 Save for Ad Hoc Deployment 保存到本地 准备在账号添加的可使用设备上使用（具体为在开发者账户下添加可用设备的udid），该app包是发布证书编译的（The app will be code signed with the distribution certificate.） Save for Enterprise Deployment 这种主要针对企业级账户下 准备本地服务器分发的app Save for Development Deployment 针对内部测试使用，主要给开发者的设备(具体也为在开发者账户下添加可用设备的udid)。该app包是开发证书编译的（The app will be code signed with your development certificate）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安全性与隐私设置]]></title>
    <url>%2F2019%2F06%2F21%2FMac%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E9%9A%90%E7%A7%81%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Mac中安装非AppStore下载的应用时经常会软件已损坏，无法安装的情况。这是需要在安全性与隐私中设置允许任何来源 打开终端 执行命令 1sudo spctl --master-disable 打开安全设置选项，就会发现「任何来源」选项回来了 PS:其实对于升级系统前，已经是任何来源选项的，还会显示，不会改变，但别的选项的，升级后就会消失.]]></content>
      <categories>
        <category>Mac相关</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不花钱的百度网盘SVIP]]></title>
    <url>%2F2019%2F06%2F21%2F%E4%B8%8D%E8%8A%B1%E9%92%B1%E7%9A%84%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98SVIP%2F</url>
    <content type="text"><![CDATA[百度网盘非SVIP下载网速受限，上传文件大小受限怎么办？ 充会员，那是不可能的，哈哈！ 敲黑板，划重点 macOS上先安装好百度网盘 登录账号 执行脚本 1cd ~/Downloads &amp;&amp; git clone https://github.com/CodeTips/BaiduNetdiskPlugin-macOS.git &amp;&amp; ./BaiduNetdiskPlugin-macOS/Other/[Install.sh] 打开百度网盘，开始享受SVIP吧]]></content>
      <categories>
        <category>Mac相关</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
</search>
